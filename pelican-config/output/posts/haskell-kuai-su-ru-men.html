<!Doctype html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<meta name="renderer" content="webkit">
<meta name="HandheldFriendly" content="True">
<meta name="google-site-verification" content="xRiYQAQ0h0n3RXqrq0GgrdFm3BMFqDvDwwiRylv0YhQ">

<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="theme-color" content="#ffffff">
<meta name="author" content="loggerhead" />    <meta name="keywords" content="Haskell,编程语言" />

  <meta name="description" content="当你开始接触函数式的时候，经常能看到 Haskell 的身影。那么 Haskell 究竟具有什么特点，让众多程序员为之倾倒？百闻不如一见，看几个例子你就懂了： 1 2 3 4 5 6 7 8 9-- 从 1 到负无穷的列表 [1, 0..] -- 斐波那契数列 fibs = 0 : 1 : zipWith (+) fibs (tail fibs) -- 快速排序 quicksort [] = [] quicksort (x:xs) = (quicksort $ filter (&lt; x) xs) ++..." />

  <title>  Haskell 快速入门
</title>

<link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">

  <link rel="stylesheet" href="../theme/css/style.1cd8932.css">
 
  <link rel="icon" type="image/x-icon" href="/favicon.ico">

  <link href="../atom.xml" rel="alternate" type="application/atom+xml">
</head>
<body>

<nav class="navbar navbar-default navbar-static-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="..">loggerhead's blog</a>
    </div>
    <div class="collapse navbar-collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav">
        <li><a href="../index.html">首页</a></li>
        <li><a href="../archives.html">归档</a></li>
        <li><a href="../404.html">关于</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="https://github.com/loggerhead" target="_blank">GitHub</a></li>
        <li><a href="https://www.hackerrank.com/loggerhead" target="_blank">HackerRank</a></li>
        <li><a href="https://douban.com/people/loggerhead" target="_blank">豆瓣</a></li>
      </ul>
    </div><!--/.navbar-header -->
  </div><!--/.container -->
</nav><!--/.navbar -->

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="markdown-body article-list">
  <section id="content">
    <article>
      <header class="page-header">
        <h1>
          <a class="article-title" href="../posts/haskell-kuai-su-ru-men.html" rel="bookmark" title="Permalink to Haskell 快速入门">
            Haskell 快速入门
          </a>
        </h1>
<footer class="post-info">
  <div class="row">
    <div class="col-xs-8">
      <!-- <span class="label label-default">Tags</span> -->
        <a class="tag btn btn-xs" href="../tag/haskell.html">
          Haskell
        </a>
        <a class="tag btn btn-xs" href="../tag/bian-cheng-yu-yan.html">
          编程语言
        </a>
    </div>

    <div class="col-xs-4 time">
      <time class="pull-right" datetime="2015-10-01T21:35:00+08:00">
        2015-10-01
      </time>
    </div>
  </div>
</footer>        <hr>
      </header>
      <div class="entry-content">
        <p>当你开始接触函数式的时候，经常能看到 Haskell 的身影。那么 Haskell 究竟具有什么特点，让众多程序员为之倾倒？百闻不如一见，看几个例子你就懂了：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">-- 从 1 到负无穷的列表</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">..</span><span class="p">]</span>                                        
<span class="c1">-- 斐波那契数列</span>
<span class="nf">fibs</span> <span class="ow">=</span> <span class="mi">0</span> <span class="kt">:</span> <span class="mi">1</span> <span class="kt">:</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span>
<span class="c1">-- 快速排序</span>
<span class="nf">quicksort</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>  
<span class="nf">quicksort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">quicksort</span> <span class="o">$</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="p">(</span><span class="n">quicksort</span> <span class="o">$</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>
<span class="c1">-- 将 `*2` 和 `+3` 分别作用于列表</span>
<span class="p">[(</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1">-- [2,4,6,4,5,6]</span>
</pre></div>
</td></tr></table>

<p>通过这几个例子，可以看出 Haskell 表达能力极强。这是因为 Haskell 是一门支持 <em>惰性求值</em>、<em>模式匹配</em>、<em>列表解析</em>、<em>类型类</em> 和 <em>类型推断</em> 的 <em>强静态类型</em> &amp;&amp; <a href="https://en.wikipedia.org/wiki/Functional_programming">纯函数式</a> 语言。</p>
<p>本文主要介绍 Haskell 的语法，并不会对函数式或 Haskell 的特性进行说明。如果曾经了解过函数式语言，本文可以作为语法简介来读。如果从未接触过函数式，那么你需要 <strong>熟悉至少一门语言</strong>，并辅以适量的<a href="https://www.hackerrank.com/domains/fp/intro">习题</a>才可能入门。</p>


<div class="toc">
<ul>
<li><a href="#_1">环境</a><ul>
<li><a href="#_2">安装</a></li>
<li><a href="#_3">编译与运行</a></li>
</ul>
</li>
<li><a href="#_4">语法</a><ul>
<li><a href="#_5">注释</a></li>
<li><a href="#_6">表达式</a><ul>
<li><a href="#_7">数学运算</a></li>
<li><a href="#_8">布尔运算</a></li>
</ul>
</li>
<li><a href="#_9">列表</a></li>
<li><a href="#if">if 表达式</a></li>
<li><a href="#let">let 语句</a></li>
<li><a href="#_10">函数</a><ul>
<li><a href="#_11">匿名函数</a></li>
<li><a href="#_12">常用函数</a></li>
<li><a href="#_13">模式匹配</a></li>
<li><a href="#guards">Guards（断言）</a></li>
<li><a href="#_14">. 操作符</a></li>
<li><a href="#_15">$ 函数</a></li>
<li><a href="#where">where 语句</a></li>
<li><a href="#case">case 表达式</a></li>
<li><a href="#partial-application">Partial application（偏函数）</a></li>
</ul>
</li>
<li><a href="#typeclass">类型与 Typeclass</a><ul>
<li><a href="#_16">类型</a></li>
<li><a href="#typeclass_1">Typeclass (类型类)</a></li>
</ul>
</li>
<li><a href="#_17">其他</a></li>
</ul>
</li>
<li><a href="#_18">参考</a></li>
</ul>
</div>
<h1 id="_1">环境</h1>
<h2 id="_2">安装</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># Linux</span>
sudo apt-get install haskell-platform
<span class="c1"># OSX</span>
brew install ghc cabal-install
</pre></div>
</td></tr></table>

<h2 id="_3">编译与运行</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># 交互式解释器</span>
ghci
<span class="c1"># 编译生成二进制可执行文件</span>
ghc --make test.hs
<span class="c1"># 运行 `test.hs`（不需要编译）</span>
runghc test.hs
<span class="c1"># `runghc` 的别名</span>
runhaskell test.hs
</pre></div>
</td></tr></table>

<h1 id="_4">语法</h1>
<h2 id="_5">注释</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">-- 单行注释</span>
<span class="cm">{- </span>
<span class="cm">被 `{-` 和 `-}` 括起来的是多行注释</span>
<span class="cm">-}</span>
</pre></div>
</td></tr></table>

<h2 id="_6">表达式</h2>
<h3 id="_7">数学运算</h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="o">+</span> <span class="mi">10</span>      <span class="c1">-- 12</span>
<span class="mi">2</span> <span class="o">-</span> <span class="mi">10</span>      <span class="c1">-- -8</span>
<span class="mi">2</span> <span class="o">*</span> <span class="mi">10</span>      <span class="c1">-- 20</span>
<span class="mi">2</span> <span class="o">/</span> <span class="mi">10</span>      <span class="c1">-- 0.2</span>
<span class="mi">2</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">10</span>  <span class="c1">-- 0</span>
<span class="mi">2</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">10</span>  <span class="c1">-- 2</span>
<span class="mi">2</span> <span class="o">^</span> <span class="mi">10</span>      <span class="c1">-- 1024</span>
</pre></div>
</td></tr></table>

<h3 id="_8">布尔运算</h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">not</span> <span class="kt">True</span>         <span class="c1">-- 非</span>
<span class="kt">False</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span>    <span class="c1">-- 与</span>
<span class="kt">False</span> <span class="o">||</span> <span class="kt">True</span>    <span class="c1">-- 或</span>

<span class="mi">12345</span> <span class="o">/=</span> <span class="mi">54321</span>   <span class="c1">-- 不等于</span>
<span class="s">&quot;foo&quot;</span> <span class="o">==</span> <span class="s">&quot;foo&quot;</span>   <span class="c1">-- True       </span>
<span class="s">&quot;abc&quot;</span> <span class="o">&lt;=</span> <span class="s">&quot;bbb&quot;</span>   <span class="c1">-- True</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>   <span class="c1">-- True</span>
</pre></div>
</td></tr></table>

<p>注意：只有布尔值能进行布尔运算，所以类似 <code>0 || 1</code> 的表达式会报错。</p>
<h2 id="_9">列表</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">-- 列表中元素的类型相同</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1">-- 将 1 添加到列表 [2, 3] 的头部，时间复杂度为 O(1)</span>
<span class="mi">1</span><span class="kt">:</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1">-- 从 1 到 3 的列表，实际上是 `1:2:3:[]` 的语法糖</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="c1">-- 小写字母。字符串实际上是字符列表，即 `[Char]`</span>
<span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">]</span>          <span class="c1">-- &quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="c1">-- 根据头两个数生成列表</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>          <span class="c1">-- [1,4,7,10]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="o">..</span><span class="mi">11</span><span class="p">]</span>          <span class="c1">-- [1,4,7,10]</span>
<span class="c1">-- 无穷列表</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>               <span class="c1">-- 1 到正无穷</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">..</span><span class="p">]</span>            <span class="c1">-- 1 到负无穷</span>

<span class="c1">-- 比较两个列表。挨个元素比较大小，直到确定大小关系，时间复杂度为 O(n)</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">..</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">..</span><span class="p">]</span>
<span class="c1">-- 合并两个列表。挨个将第一个列表的元素添加到第二个列表中，时间复杂度为 O(n)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">..</span><span class="mi">9</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="s">&quot;hello&quot;</span> <span class="o">++</span> <span class="s">&quot;world&quot;</span>
<span class="c1">-- `list !! i` 表示取出列表 `list` 中下标为 `i` 的元素，下标从 0 开始</span>
<span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">999</span>

<span class="c1">-- `[2*x | x &lt;- l]` 产生了一个新列表，它的元素由列表 `l` 中的元素进行运算 `2*x` 得到</span>
<span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">]]</span>                                         <span class="c1">-- [2,4]</span>
<span class="c1">-- 对偶数计算 `2*x`</span>
<span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">9</span><span class="p">],</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>                         <span class="c1">-- [4,8,12,16]</span>
<span class="c1">-- 计算与原点的距离</span>
<span class="p">[</span><span class="n">sqrt</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]]</span>    <span class="c1">-- [1.4142135623730951,13.0,5.0]</span>
<span class="c1">-- 计算笛卡尔积</span>
<span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>                         <span class="c1">-- [(1,3),(1,4),(2,3),(2,4)]</span>
<span class="c1">-- 筛选</span>
<span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]]</span>                   <span class="c1">-- [4]</span>
</pre></div>
</td></tr></table>

<h2 id="if">if 表达式</h2>
<p>与其他语言的 if 不同，Haskell 的 if 是表达式，<em>有返回值</em>，所以 <strong>必须有 else</strong>。下面是几个例子：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">if</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="s">&quot;good&quot;</span> <span class="kr">else</span> <span class="s">&quot;WTF?!&quot;</span>
<span class="p">[</span><span class="kr">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="o">-</span><span class="mi">1</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="o">..</span><span class="mi">12</span><span class="p">]]</span>
</pre></div>
</td></tr></table>

<h2 id="let">let 语句</h2>
<p><code>let</code> 将表达式或值绑定到变量，例如：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="mi">3</span>
<span class="nf">c</span> <span class="o">==</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">2</span> <span class="kr">in</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</td></tr></table>

<p><code>let</code> 有 <code>let ...</code> 和 <code>let ... in ...</code> 两种形式。前者只能出现在 <code>do</code> 或列表解析中 <code>|</code> 的后面，后者在任何表达式能够存在的地方都可以出现。例如：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">-- 出现在 `do` 中</span>
<span class="kr">do</span> <span class="n">statements</span>
   <span class="kr">let</span> <span class="n">var1</span> <span class="ow">=</span> <span class="n">expr1</span>
       <span class="n">var2</span> <span class="ow">=</span> <span class="n">expr2</span>
   <span class="n">statements</span>

<span class="c1">-- 出现在列表解析中</span>
<span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">],</span> <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">]</span>                 <span class="c1">-- [(1,2),(2,4)]</span>

<span class="c1">-- 作为表达式</span>
<span class="p">(</span><span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">2</span> <span class="kr">in</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>                     <span class="c1">-- 6</span>
<span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">],</span> <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="kr">in</span> <span class="n">a</span><span class="o">+</span><span class="n">x</span><span class="p">]</span>  <span class="c1">-- [(1,2),(2,6)]</span>
</pre></div>
</td></tr></table>

<h2 id="_10">函数</h2>
<p>函数的语法形式如下：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">name</span> <span class="n">arg1</span> <span class="n">arg2</span> <span class="ow">=</span> <span class="n">do_something_with_args</span>
</pre></div>
</td></tr></table>

<p>Haskell 的函数有几个特点：</p>
<ul>
<li>函数参数之间用空格隔开</li>
<li>任何函数都有返回值</li>
<li>函数名不一定要是字母，例如：</li>
</ul>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span>
<span class="kr">let</span> <span class="p">(</span><span class="o">%</span><span class="p">)</span> <span class="ow">=</span> <span class="n">mod</span>
<span class="kr">let</span> <span class="n">pp&#39;</span> <span class="ow">=</span> <span class="n">succ</span>

<span class="nf">pp&#39;</span> <span class="mi">2</span>                   <span class="c1">-- 3</span>
<span class="mi">1</span> <span class="o">%</span> <span class="mi">2</span>                   <span class="c1">-- 1</span>
<span class="s">&quot;hello&quot;</span> <span class="o">+</span> <span class="s">&quot;world&quot;</span>       <span class="c1">-- &quot;helloworld&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="_11">匿名函数</h3>
<p>匿名函数是没有名字的函数，它符合<a href="https://zh.wikipedia.org/wiki/Λ演算">λ演算</a>，其语法如下。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="n">arg1</span> <span class="n">arg2</span> <span class="ow">-&gt;</span> <span class="n">do_something_with_args</span>
</pre></div>
</td></tr></table>

<p>也许因为 <code>\</code> 看起来像 λ，所以被用来定义匿名函数吧。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">5</span>                                           <span class="c1">-- 8</span>
<span class="p">[</span><span class="n">is_odd</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span> <span class="kr">let</span> <span class="n">is_odd</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>   <span class="c1">-- [True,False,True,False,True]</span>
<span class="nf">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">acc</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>                          <span class="c1">-- 12</span>
</pre></div>
</td></tr></table>

<h3 id="_12">常用函数</h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">-- 类似于 `i++`</span>
<span class="nf">succ</span> <span class="mi">2</span>                          <span class="c1">-- 3</span>

<span class="c1">-- 取出元组第一个元素</span>
<span class="nf">fst</span> <span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">)</span>          <span class="c1">-- &quot;hello&quot;</span>
<span class="nf">snd</span> <span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">)</span>          <span class="c1">-- &quot;world&quot;</span>

<span class="nf">head</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                     <span class="c1">-- 1</span>
<span class="nf">tail</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                     <span class="c1">-- [2,3,4,5]</span>
<span class="nf">last</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                     <span class="c1">-- 5</span>
<span class="c1">-- 丢弃最后一个元素形成的列表</span>
<span class="nf">init</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                     <span class="c1">-- [1,2,3,4]</span>

<span class="nf">length</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                   <span class="c1">-- 5</span>
<span class="c1">-- 检查列表是否为空</span>
<span class="nf">null</span> <span class="kt">[]</span>                         <span class="c1">-- True</span>
<span class="c1">-- 检查列表中是否存在元素 9</span>
<span class="nf">elem</span> <span class="mi">9</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                   <span class="c1">-- False</span>

<span class="c1">-- 反转列表</span>
<span class="nf">reverse</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                  <span class="c1">-- [5,4,3,2,1]</span>
<span class="c1">-- 取出列表的前 5 个元素组成新列表</span>
<span class="nf">take</span> <span class="mi">5</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>                    <span class="c1">-- [1,2,3,4,5]</span>
<span class="c1">-- 丢弃列表的前 5 个元素组成新列表</span>
<span class="nf">drop</span> <span class="mi">5</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">9</span><span class="p">]</span>                   <span class="c1">-- [6,7,8,9]</span>
<span class="c1">-- 生成具有 5 个重复元素 &#39;a&#39; 的新列表</span>
<span class="nf">replicate</span> <span class="mi">5</span> <span class="sc">&#39;a&#39;</span>                 <span class="c1">-- &quot;aaaaa&quot;</span>

<span class="nf">sum</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                      <span class="c1">-- 15</span>
<span class="c1">-- 1*2*3*4*5</span>
<span class="nf">product</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                  <span class="c1">-- 120</span>
<span class="nf">maximum</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                  <span class="c1">-- 5</span>
<span class="nf">minimum</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                  <span class="c1">-- 1</span>

<span class="c1">-- `foldl f acc list` 相当于 `foreach x in list do acc = f(acc, x)`</span>
<span class="nf">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>              <span class="c1">-- sum [1..5]</span>
<span class="nf">foldl</span> <span class="n">max</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>              <span class="c1">-- maximum [1..5]</span>
<span class="c1">-- `foldr` 与 `foldl` 类似，只不过是从右到左遍历列表</span>
<span class="nf">foldr</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>              <span class="c1">-- 3</span>
<span class="nf">foldl</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>              <span class="c1">-- -15</span>
<span class="c1">-- `map f list` 相当于 `[f(x) | x &lt;- list]`</span>
<span class="nf">map</span> <span class="n">succ</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>                 <span class="c1">-- [succ x | x &lt;- [1..5]]</span>
<span class="c1">-- 过滤掉不满足 `x &gt; 0` 的元素</span>
<span class="nf">filter</span> <span class="p">(</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>            <span class="c1">-- [1,2,3,4,5]</span>
<span class="c1">-- `zip a b` 将列表 `a`、`b` 合并成新列表 `c`，其中 `c !! i == (a !! i, b !! i)`</span>
<span class="nf">zip</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">..</span><span class="mi">9</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>            <span class="c1">-- [(1,2),(3,4)]</span>
<span class="c1">-- `zipWith f a b` 将列表 `a`、`b` 合并成新列表 `c`，其中 `c !! i == f (a !! i) (b !! i)`</span>
<span class="nf">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">..</span><span class="mi">9</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>    <span class="c1">-- [3,7]</span>
</pre></div>
</td></tr></table>

<h3 id="_13">模式匹配</h3>
<p>当定义函数时，可以为不同的模式定义不同的函数体。那到底什么是模式呢？我们先看一个例子感受一下。</p>
<p>新建文件 <code>test.hs</code>，输入下面的代码，保存后在命令行输入 <code>runhaskell test.hs</code> 运行。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">fibo</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">fibo</span> <span class="mi">1</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fibo</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">fibo</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibo</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">fibo</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>当调用 <code>fibo 2</code> 时，Haskell 会从上到下依次尝试进行模式匹配。先尝试 <code>0</code> 和 <code>1</code>，发现与参数 <code>2</code> 不匹配，直到尝试最后一个模式时，发现匹配变量 <code>n</code>，所以执行 <code>fibo n</code> 对应的函数体。</p>
<p>模式匹配不仅是可以对数字进行匹配，还可以对列表和元组等进行匹配，例如：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">-- 匹配空列表</span>
<span class="nf">first</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="c1">-- `(x:[])` 匹配列表 `[x]`。在模式中出现的变量可以直接使用，表示匹配到的值</span>
<span class="nf">first</span> <span class="p">(</span><span class="n">x</span><span class="kt">:[]</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;LAST</span><span class="se">\t</span><span class="s">=&gt; &quot;</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> 
<span class="c1">-- `@` 前面的 `all` 表示整个列表。好处是当需要使用列表时，不需要通过 `x:xs` 再生成一次</span>
<span class="nf">first</span> <span class="n">all</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">all</span> <span class="o">++</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">=&gt; &quot;</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">++</span> <span class="n">first</span> <span class="n">xs</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">first</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>注意，不能在模式匹配中使用 <code>++</code>，因为匹配 <code>(xs ++ ys)</code> 可能导致二义性。比如：<code>[1,2,3]</code> 可以是 <code>([1] ++ [2,3])</code>，也可以是 <code>([1,2] ++ [3])</code>，鬼知道匹配哪一个！</p>
<h3 id="guards">Guards（断言）</h3>
<p>断言类似于 C 语言中的 <code>switch</code>，它会对每一个断言求值，直到遇到 <code>True</code>，再执行所对应的逻辑。例如：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">phase</span> <span class="n">age</span> 
    <span class="o">|</span> <span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">18</span> <span class="ow">=</span> <span class="s">&quot;Fire&quot;</span>
    <span class="o">|</span> <span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">30</span> <span class="ow">=</span> <span class="s">&quot;Sublime&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="s">&quot;Wisdom&quot;</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">phase</span> <span class="mi">22</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p><code>phase 22</code> 调用会先检查 <code>22 &lt;= 18</code>，发现为 <code>False</code>，接着检查下一个断言 <code>22 &lt;= 30</code>，为 <code>True</code>，于是执行 <code>age &lt;= 30</code> 后面的代码。</p>
<p>断言中出现的 <code>otherwise</code> 类似于 <code>switch</code> 中的 <code>default</code>，如果 <code>otherwise</code> 前面的所有断言都为 <code>False</code>，那么执行 <code>otherwise</code> 后面的逻辑。</p>
<h3 id="_14"><code>.</code> 操作符</h3>
<p><code>.</code> 是一个函数组合操作符。功能类似于 Unix 中的管道符 <code>|</code>，它会将前一个函数的输出作为后一个函数的输入。先看一个例子：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">succ</span> <span class="o">.</span> <span class="n">sum</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>         <span class="c1">-- 16</span>
</pre></div>
</td></tr></table>

<p><code>.</code> 将 <code>succ</code> 和 <code>sum</code> 组合到一起，形成一个新函数 <code>succ . sum</code>，然后将 <code>[1..5]</code> 作为参数调用这个函数。等价于 <code>succ (sum [1..5])</code>。和<a href="https://www.mathsisfun.com/sets/functions-composition.html">数学</a>上的 <code>f∘g (x) &lt;=&gt; f(g(x))</code> 概念一样。这里不多作介绍，如果感兴趣，可以看看 <a href="https://stackoverflow.com/questions/20279306/what-does-f-g-mean-in-haskell#answer-20279307">StackOverflow 上的回答</a>。</p>
<p>下面给出一个比较复杂的例子，帮助理解 <code>.</code> 操作符。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">upper_name</span> <span class="p">(</span><span class="n">fst</span><span class="kt">:</span><span class="n">snd</span><span class="kt">:</span><span class="n">others</span><span class="p">)</span> <span class="ow">=</span> <span class="n">capitalized</span> <span class="n">fst</span><span class="kt">:</span><span class="n">capitalized</span> <span class="n">snd</span><span class="kt">:</span><span class="n">others</span>
    <span class="kr">where</span> <span class="n">capitalized</span> <span class="p">(</span><span class="n">fst</span><span class="kt">:</span><span class="n">remains</span><span class="p">)</span> <span class="ow">=</span> <span class="n">toUpper</span> <span class="n">fst</span> <span class="kt">:</span> <span class="n">remains</span>

<span class="nf">cap_names</span> <span class="ow">=</span> <span class="n">unlines</span> <span class="o">.</span> <span class="n">map</span> <span class="n">unwords</span> <span class="o">.</span> <span class="n">map</span> <span class="n">upper_name</span> <span class="o">.</span> <span class="n">map</span> <span class="n">words</span> <span class="o">.</span> <span class="n">lines</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">putStr</span> <span class="p">(</span><span class="n">cap_names</span> <span class="s">&quot;neo loggerhead</span><span class="se">\n</span><span class="s">foo bar&quot;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>输出是：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Neo Loggerhead
Foo Bar
</pre></div>
</td></tr></table>

<h3 id="_15"><code>$</code> 函数</h3>
<p><code>$</code> 函数，又被称为 <em>function application</em>。不管有啥用，我们先看一个例子：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">-- 等价于 succ (cos (sin 1))</span>
<span class="nf">succ</span> <span class="o">$</span> <span class="n">cos</span> <span class="o">$</span> <span class="n">sin</span> <span class="mi">1</span>
</pre></div>
</td></tr></table>

<p>其实 <code>$</code> 只是一个语法糖，它具有最低优先级。可以认为 <code>$</code> 给随后的语句加了一对括号，即把 <code>$</code> 替换成 <code>(</code>，并在最右边加上了 <code>)</code>。其优点是：当函数调用很长时，避免了产生一堆影响可读性的括号。</p>
<h3 id="where">where 语句</h3>
<p>同样，话不多说，先看一个计算 BMI<sup id="fnref:bmi"><a class="footnote-ref" href="#fn:bmi" rel="footnote">1</a></sup> 的函数：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">bmi</span> <span class="n">weight</span> <span class="n">height</span>  
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>  
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">25.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>  
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">30.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>  
    <span class="o">|</span> <span class="n">otherwise</span>                   <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>  
</pre></div>
</td></tr></table>

<p>不难看出 <code>weight / height ^ 2</code> 被重复计算了多次，违背了 DRY 原则<sup id="fnref:DRY"><a class="footnote-ref" href="#fn:DRY" rel="footnote">2</a></sup>。为了减少重复运算，增加可读性，可以将 <code>bmi</code> 改写成：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">bmi</span> <span class="n">weight</span> <span class="n">height</span>  
    <span class="o">|</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">skinny</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>  
    <span class="o">|</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">normal</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>  
    <span class="o">|</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">fat</span>    <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>  
    <span class="o">|</span> <span class="n">otherwise</span>   <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span> 
    <span class="kr">where</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span>
          <span class="p">(</span><span class="n">skinny</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">fat</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">18.5</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">)</span> 

<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">bmi</span> <span class="mi">70</span> <span class="mf">1.75</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p><code>where</code> 语句与 <code>let</code> 语句作用类似，都能将值与变量绑定，方便随后的使用，其不同之处包括：</p>
<ul>
<li><code>where</code> 中可以使用模式匹配</li>
<li><code>where</code> 中绑定的变量的作用域是整个函数</li>
<li><code>where</code> 是语句，不是表达式</li>
</ul>
<h3 id="case">case 表达式</h3>
<p>case 表达式和 if 表达式类似，都有返回值。但是 case 还能进行模式匹配。实际上，函数参数中的模式匹配就是 case 表达式的语法糖。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">{-</span>
<span class="cm">case expression of pattern -&gt; result  </span>
<span class="cm">                   pattern -&gt; result  </span>
<span class="cm">                   pattern -&gt; result  </span>
<span class="cm">                   ...  </span>
<span class="cm">-}</span>

<span class="nf">classify</span> <span class="n">age</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">age</span> <span class="kr">of</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="s">&quot;newborn&quot;</span>
                           <span class="mi">1</span> <span class="ow">-&gt;</span> <span class="s">&quot;infant&quot;</span>
                           <span class="mi">2</span> <span class="ow">-&gt;</span> <span class="s">&quot;toddler&quot;</span>
                           <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="s">&quot;senior citizen&quot;</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="o">$</span> <span class="n">classify</span> <span class="mi">18</span>
</pre></div>
</td></tr></table>

<p>注意，模式匹配中的 <code>_</code> 能匹配任何值。</p>
<h3 id="partial-application">Partial application（偏函数）</h3>
<p>Haskell 中的所有函数都是 <strong>单参函数</strong>。多参函数本质上是对单参函数的多次求值，例如：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">max</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="cm">{- 等价于</span>
<span class="cm">let maxWith2 = max 2</span>
<span class="cm">maxWith2 3</span>
<span class="cm">-}</span>
</pre></div>
</td></tr></table>

<p><code>max 2 3</code> 等价于 <code>(max 2) 3</code>，<code>max</code> 接收 <code>2</code> 作为参数，并返回一个新函数 <code>maxWith2</code>，接着执行 <code>maxWith2 3</code> 得到较大值。这样的好处是，我们能创造偏函数<sup id="fnref:Partial_application"><a class="footnote-ref" href="#fn:Partial_application" rel="footnote">3</a></sup>，而偏函数很多时候用起来超级方便。例如：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">-- 计算两点距离</span>
<span class="kr">let</span> <span class="n">distance</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">sqrt</span> <span class="o">$</span> <span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="c1">-- 计算到原点距离的偏函数</span>
<span class="kr">let</span> <span class="n">distanceToOrigin</span> <span class="ow">=</span> <span class="n">distance</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nf">distanceToOrigin</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1">-- `(&gt; 0)` 等价于 `\x -&gt; x &gt; 0`</span>
<span class="nf">filter</span> <span class="p">(</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>            <span class="c1">-- [1,2,3,4,5]</span>
<span class="c1">-- `(max 0)` 等价于 `\x -&gt; max 0 x`</span>
<span class="nf">map</span> <span class="p">(</span><span class="n">max</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>             <span class="c1">-- [0,0,0,0,0,0,1,2,3,4,5]</span>

<span class="kr">let</span> <span class="n">add1</span> <span class="ow">=</span> <span class="n">succ</span> <span class="o">.</span> <span class="n">max</span> <span class="mi">0</span>
<span class="c1">-- `-1` 必须括起来，否则会被解释为做减法</span>
<span class="nf">add1</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">-- 等价于 `add1 $ -1`，为什么？ </span>
</pre></div>
</td></tr></table>

<h2 id="typeclass">类型与 Typeclass</h2>
<h3 id="_16">类型</h3>
<p>文章一开始就提到了 Haskell 是强静态类型语言，这是因为 Haskell 中的所有东西都有类型。我们可以在 GHCI 中使用 <code>:t anything</code> 命令查看 <code>anything</code> 的类型，比如：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Prelude&gt; :t (.)
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
Prelude&gt; :t 123
123 :: Num a =&gt; a
Prelude&gt; :t &#39;a&#39;  
&#39;a&#39; :: Char  
Prelude&gt; :t 4 == 5  
4 == 5 :: Bool  
Prelude&gt; :t mod
mod :: Integral a =&gt; a -&gt; a -&gt; a
</pre></div>
</td></tr></table>

<p>不难发现，<code>::</code> 前面是表达式，后面是表达式的类型说明，并且 <em>类型都以大写字母开头</em>。其中，<code>=&gt;</code> 叫 <em>类约束（class constraint）</em>，用来指明类型属于哪些 typeclass，<code>a</code>、<code>b</code>、<code>c</code>等出现在类型说明中的小写字母叫 <em>类型变量（type variable）</em>。我们看个例子：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">mod</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</td></tr></table>

<p>上面的类型说明可以理解为：<code>mod</code> 函数接收两个同一类型 <code>a</code> 的参数，返回值也是类型 <code>a</code>，并且类型 <code>a</code> 属于 <code>Integral</code> typeclass。</p>
<p>常见的类型包括：</p>
<ul>
<li><code>Int</code>: 有界限的整数。比如：32 位机器的最小 <code>Int</code> 是 <code>-2147483648</code></li>
<li><code>Integer</code>: 无界限的整数。可以表达很大很大的整数</li>
<li><code>Float</code>: 单精度浮点数</li>
<li><code>Double</code>: 双精度浮点数</li>
<li><code>Bool</code>: 布尔类型</li>
<li><code>Char</code>: 字符类型</li>
<li><code>()</code>: 空元组</li>
<li><code>Ordering</code>: 取值为 <code>GT</code>、<code>LT</code> 或 <code>EQ</code>，分别是 <code>greater than</code>、<code>lesser than</code> 和 <code>equal</code> 的缩写</li>
</ul>
<p>与 C 和 Java 等语言不一样，Haskell 是具有 <em>类型推断</em> 的 <strong>强</strong> 静态类型语言。这意味着：</p>
<ul>
<li>Haskell 会自动推断表达式或函数的类型，所以在定义函数的时候不需要声明类型</li>
<li><strong>不会自动进行类型转换</strong>。因此 <code>Int</code> 和 <code>Double</code> 不能直接进行运算，比如：</li>
</ul>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Prelude&gt; (1::Int) == (1::Double)

&lt;interactive&gt;:66:14:
    Couldn&#39;t match expected type ‘Int’ with actual type ‘Double’
    In the second argument of ‘(==)’, namely ‘(1 :: Double)’
    In the expression: (1 :: Int) == (1 :: Double)
    In an equation for ‘it’: it = (1 :: Int) == (1 :: Double)
</pre></div>
</td></tr></table>

<h3 id="typeclass_1">Typeclass (类型类)</h3>
<p>Typeclass 与常常出现在面向对象中的 <em>接口</em> 类似。常见 typeclass 如下：</p>
<ul>
<li><code>Num</code>: 数字</li>
<li><code>Integral</code>: 整型数</li>
<li><code>Floating</code>: 浮点数</li>
<li><code>Eq</code>: 能测试相等。属于 <code>Eq</code> 的类型必须实现 <code>(/=)</code> 或 <code>(==)</code> 函数</li>
<li><code>Ord</code>: 能比较顺序。属于 <code>Ord</code> 的类型必须实现 <code>compare</code> 或 <code>(&lt;=)</code> 函数</li>
<li><code>Show</code>: 能转换成字符串。属于 <code>Show</code> 的类型必须实现 <code>show</code> 函数。除了函数以外的所有的类型都属于 <code>Show</code> 类</li>
<li><code>Read</code>: 与 <code>Show</code> 相反。属于 <code>Read</code> 的类型必须实现 <code>read</code> 函数</li>
</ul>
<p>比如，<code>1 :: Int</code> 就属于 <code>Num</code>、<code>Integral</code>、<code>Eq</code>、<code>Ord</code>、<code>Show</code>。下面给出一些常见的用法：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">show</span> <span class="mi">123</span>                <span class="c1">-- &quot;123&quot;</span>
<span class="c1">-- 类型推断会自动将 `read &quot;2&quot;` 转换成 `read &quot;2&quot; :: Int`</span>
<span class="mi">1</span> <span class="o">+</span> <span class="n">read</span> <span class="s">&quot;2&quot;</span>            <span class="c1">-- 3</span>
<span class="c1">-- Haskell 不知道该将 `&quot;2&quot;` 转换成 `Int`、`Integer` 还是 `Float`，所以会报错</span>
<span class="c1">-- read &quot;2&quot;</span>

<span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">1</span> <span class="ow">::</span> <span class="kt">Double</span>
<span class="kr">let</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="c1">-- fromIntegral 将 `Integral` 转换成 `Num`</span>
<span class="nf">a</span> <span class="o">+</span> <span class="n">fromIntegral</span> <span class="n">b</span>      <span class="c1">-- 2</span>
<span class="c1">-- `+` 的类型是 `(+) :: Num a =&gt; a -&gt; a -&gt; a`</span>
<span class="c1">-- 类比面向对象中的多态和泛型的概念，想想为什么 `a`、`b` 不能直接相加</span>
</pre></div>
</td></tr></table>

<p>注意：如果从上下文不能推断出 <code>read</code> 的返回值是什么类型，一定要 <strong>明确指明类型</strong></p>
<h2 id="_17">其他</h2>
<p>下面给出的内容不太容易掌握，不适宜放在快速入门中，如果感兴趣，可以自己看一下 <a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!</a> <sup id="fnref:HASKELL 趣学指南"><a class="footnote-ref" href="#fn:HASKELL 趣学指南" rel="footnote">4</a></sup> 的相关章节：</p>
<ul>
<li><a href="http://learnyouahaskell.com/modules">模块</a></li>
<li><a href="http://learnyouahaskell.com/input-and-output">输入输出</a></li>
<li><a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses">类型与类型类</a></li>
<li><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">Functors, Applicative, and Monoids</a></li>
</ul>
<h1 id="_18">参考</h1>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Haskell">Wiki: Haskell</a></li>
<li><a href="http://learnxinyminutes.com/docs/haskell/">Learn X in Y minutes: Haskell</a></li>
<li><a href="http://learnyouahaskell.com/chapters">Learn You Some Haskell</a></li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:bmi">
<p><a href="https://zh.wikipedia.org/wiki/身高體重指數">身高体重指数（Body Mass Index）</a>&#160;<a class="footnote-backref" href="#fnref:bmi" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:DRY">
<p>意为：<a href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">Don't repeat yourself</a>，即尽可能的减少重复的逻辑和计算&#160;<a class="footnote-backref" href="#fnref:DRY" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:Partial_application">
<p>详见 <a href="https://en.wikipedia.org/wiki/Partial_application">wiki</a>&#160;<a class="footnote-backref" href="#fnref:Partial_application" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:HASKELL 趣学指南">
<p>英文不好的同学可以看 <a href="http://learnyoua.haskell.sg/content/zh-cn/index.html">中文版</a>&#160;<a class="footnote-backref" href="#fnref:HASKELL 趣学指南" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      </div>
    </article>
  </section>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
    this.page.identifier = "Haskell 快速入门";
};

(function() {
    var d = document, s = d.createElement('script');
    s.async = true;
    s.src = "//loggerhead.disqus.com/embed.js";
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>      </div>
    </div>
  </div>
</div>

 <footer class="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-xs-8">
        <p>
          &copy;2016&nbsp; <a href="..">loggerhead</a>
        </p>
      </div>
      <div class="col-xs-4">
        <p class="pull-right">
          <a href="#" class="back-to-top">
            <span class="glyphicon glyphicon-arrow-up" aria-hidden="true"></span>
            回到顶部
          </a>
        </p>
      </div>
    </div>

    <div class="row hidden-when-phone">
      <div class="col-xs-8">
        <p>
          <a href="http://www.miitbeian.gov.cn/" target="_blank">粤ICP备16007488号</a>
          &middot; Powered by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a>
        </p>

        <p>
          本站文章均为原创，并遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh_TW" target="_blank">CC BY-SA 4.0 协议</a>
        </p>
      </div><!--/.col-xs-8 -->

      <div class="col-xs-4">
        <p class="pull-right">
          <a href="https://www.upyun.com/zh/league.html" target="_blank">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAtCAMAAAAZUYxJAAAAtFBMVEUAAABPrtxPrtxPrtxPrtxPrtxlZ2ZlZ2ZPrtxlZ2ZRqdRlZ2ZPrtxPrtxPrtxPrtxPrtxlZ2ZPrtxlZ2ZPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxlZ2ZPrtxPrtxPrtxlZ2ZlZ2ZPrtxlZ2ZlZ2ZPrtxPrtxlZ2ZlZ2ZlZ2ZlZ2ZlZ2ZPrtxPrtxlZ2ZPrtxlZ2ZlZ2ZlZ2ZPrtxPrtxlZ2ZPrtxlZ2bPPWi/AAAAOnRSTlMAgNCQ8aAQcD8fA/FPMevhsDD5wLp1cCHZypmHOwyrooFTGhLh0sSwinlfXfju67yMRyfcooZ4RS0XProUtAAAAZlJREFUSMft02tT4jAUxvHTNtAaobjd3iyUq1zE1V1dr0++//fypMGZCrbw1jG/N2nD8KcTTsmyLOvH6sUC4Tio7fxWyufll1KKqKu0P7fLpy7veUCHlwAAfxMYELsAHKIOtCiMe2TICQxPNqeNq7OjaWNGlX+Ixo4TAxg2p6e+/8jL32PpVZomLnBJWhZdzomNQiBrTJ/x3Y1ej6Q9XQIi0tJwQZUAGC7KlrS8VermhHS/+khuR8U17cRg+bYxTUvePTUtL+5p0iejdIJ5vwCKxqc+3z315IR0wsftLMgwB51Uf+9aqc1B2uf1gYbAapc2x1p+mc4nfDGnOikQE015jje+v6lNyPPaTMgMQJGmXpUuIyBO0tQ9SFdDIumTAf4Tvd0p43CupYsP1eQaB2mBF9oTmKF8WF+dGybNF3fLaZfYYpgLAGbCZOIKg6ehEEK/Gq98R2OIraS6Xqh//zNz1ntmQEgtMgGEbg2HkZet6Z6ndQbAmNr0c+xbZdSa9rATZtRK3l87dcmIqD2duJXYmZNlWZb17b0DTmto7227YPgAAAAASUVORK5CYII=" />
          </a>
        </p>
      </div>
    </div>
  </div>
</footer>
    <script src="../theme/js/bag.2.0.2.min.js"></script>

<script id="myscripts">
bag = new window.Bag();

bag.require([
    "//cdn.bootcss.com/jquery/2.2.1/jquery.min.js",
    "//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"
]);

function load_css(url, done) {
    var link  = document.createElement('link');
    link.rel  = 'stylesheet';
    link.href = url;
    link.onload = done;
    document.head.appendChild(link);
}

function load_js(url, done) {
    var script = document.createElement('script');
    script.src = url;
    script.onload = done;
    document.body.appendChild(script);
}

function gestureStart() {
    for (i = 0; i < metas.length; i++) {
        if (metas[i].name == "viewport") {
            metas[i].content = "width=device-width, minimum-scale=0.25, maximum-scale=1.6";
        }
    }
}

(function screen_suit() {
    var metas = document.getElementsByTagName('meta');
    var ua = navigator.userAgent;
    if (ua.match(/iPhone/i)) {
        for (var i = 0; i < metas.length; i++) {
            if (metas[i].name == "viewport") {
                metas[i].content = "width=device-width, minimum-scale=1.0, maximum-scale=1.0";
            }
        }
        document.addEventListener("gesturestart", gestureStart, false);
    }
})();

// See https://gist.github.com/vartan/ab195e5a502a47e0c3e5
(function fix_hover_behavior() {
    if('ontouchstart' in document.documentElement) {
        for(var sheetI = document.styleSheets.length - 1; sheetI >= 0; sheetI--) {
            var sheet = document.styleSheets[sheetI];
            if(sheet.cssRules) {
                for(var ruleI = sheet.cssRules.length - 1; ruleI >= 0; ruleI--) {
                    var rule = sheet.cssRules[ruleI];
                    if(rule.selectorText) {
                        rule.selectorText = rule.selectorText.replace(":hover", ":active");
                    }
                }
            }
        }
    }
})();

(function add_class_to_chinese_em(class_name) {
    var ems = document.getElementsByTagName("em");

    for (var i = 0; i < ems.length; i++) {
        var text = ems[i].textContent;
        // if has chinese char
        if(/.*[\u4e00-\u9fa5]+.*$/.test(text)) {
            ems[i].className += " " + class_name;
        }
    }
})('chinese');

// IE10 viewport hack for Surface/desktop Windows 8 bug
(function fix_ie10_viewport_bug() {
    if (navigator.userAgent.match(/IEMobile\/10\.0/)) {
        bag.require([
            "//maxcdn.bootstrapcdn.com/css/ie10-viewport-bug-workaround.css",
            "//maxcdn.bootstrapcdn.com/js/ie10-viewport-bug-workaround.js"
        ]);
    }
})();

(function load_katex_when_need(class_name) {
    var maths = document.getElementsByClassName(class_name);
    if (maths.length == 0) {
        return;
    }

    bag.require([
        "//cdn.bootcss.com/KaTeX/0.6.0/katex.min.js"
    ]).then(function() {
        for (var i = 0; i < maths.length; i++) {
            var math = maths[i];

            var displayMode = null;
            if (math.tagName == "SPAN") {
                displayMode = false;
            } else if (math.tagName == "DIV") {
                displayMode = true;
            }

            if (displayMode === null) {
                console.log("Cannot render " + math);
            } else {
                try {
                    katex.render(math.textContent, maths[i], { displayMode: displayMode });
                } catch (err) {
                    console.log(err);
                }
            }
        }
    });

    load_css("//cdn.bootcss.com/KaTeX/0.6.0/katex.min.css");
})("math");
</script>

<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script>
  bag.require([
    "//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js",
    "//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"
  ]);
  </script>
<![endif]-->
 
</body>
</html>