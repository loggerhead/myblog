<!Doctype html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<meta name="renderer" content="webkit">
<meta name="HandheldFriendly" content="True">
<meta name="google-site-verification" content="xRiYQAQ0h0n3RXqrq0GgrdFm3BMFqDvDwwiRylv0YhQ">

<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="theme-color" content="#ffffff">
<meta name="author" content="loggerhead" />    <meta name="keywords" content="Erlang,编程语言" />

  <meta name="description" content="在很多语言中，我们都能看到 函数式范型、动态类型、类型系统 的身影，而 Erlang 在此基础上发展出了一些自成一派的特点： 轻量级进程。Erlang 的进程既不是操作系统层面的进程，也不是线程，而是由 Erlang 虚拟机进行管理调度的无状态的进程。建立一个进程的成本非常低，在博主机器上（2.4 GHz Intel Core i5，8 GB 1600 MHz DDR3）平均只需要 2~4 us，而建立 80 万个进程也只花费了几秒的时间，并且据官方说法，建立一个进程的内存占用不到 400 字。 消..." />

  <title>  Erlang 快速入门
</title>

<link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">

  <link rel="stylesheet" href="../theme/css/style.1cd8932.css">
 
  <link rel="icon" type="image/x-icon" href="/favicon.ico">

  <link href="../atom.xml" rel="alternate" type="application/atom+xml">
</head>
<body>

<nav class="navbar navbar-default navbar-static-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="..">loggerhead's blog</a>
    </div>
    <div class="collapse navbar-collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav">
        <li><a href="../index.html">首页</a></li>
        <li><a href="../archives.html">归档</a></li>
        <li><a href="../404.html">关于</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="https://github.com/loggerhead" target="_blank">GitHub</a></li>
        <li><a href="https://www.hackerrank.com/loggerhead" target="_blank">HackerRank</a></li>
        <li><a href="https://douban.com/people/loggerhead" target="_blank">豆瓣</a></li>
      </ul>
    </div><!--/.navbar-header -->
  </div><!--/.container -->
</nav><!--/.navbar -->

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="markdown-body article-list">
  <section id="content">
    <article>
      <header class="page-header">
        <h1>
          <a class="article-title" href="../posts/erlang-kuai-su-ru-men.html" rel="bookmark" title="Permalink to Erlang 快速入门">
            Erlang 快速入门
          </a>
        </h1>
<footer class="post-info">
  <div class="row">
    <div class="col-xs-8">
      <!-- <span class="label label-default">Tags</span> -->
        <a class="tag btn btn-xs" href="../tag/erlang.html">
          Erlang
        </a>
        <a class="tag btn btn-xs" href="../tag/bian-cheng-yu-yan.html">
          编程语言
        </a>
    </div>

    <div class="col-xs-4 time">
      <time class="pull-right" datetime="2015-08-21T21:08:25+08:00">
        2015-08-21
      </time>
    </div>
  </div>
</footer>        <hr>
      </header>
      <div class="entry-content">
        <p>在很多语言中，我们都能看到 <strong>函数式范型</strong>、<strong>动态类型</strong>、<strong>类型系统</strong> 的身影，而 Erlang 在此基础上发展出了一些自成一派的特点：</p>
<ul>
<li><strong>轻量级进程</strong>。Erlang 的进程既不是操作系统层面的进程，也不是线程，而是由 Erlang 虚拟机进行管理调度的无状态的进程。建立一个进程的成本非常低，在博主机器上（2.4 GHz Intel Core i5，8 GB 1600 MHz DDR3）平均只需要 2~4 us，而建立 80 万个进程也只花费了几秒的时间，并且据官方说法，建立一个进程的内存占用不到 400 字。</li>
<li><strong>消息原语</strong>。Erlang 直接在语言层面支持进程间通讯，并且在内部对并发进行了同步处理，用户不需要再关心多进程并发会不会发生同步问题，大大降低了在进程间传递消息的难度。例如，一句话就能搞定发消息：<code>Pid ! Message.</code>，收消息也就多个匹配和处理的过程：<code>receive Message -&gt; handle(Message) end.</code>。</li>
<li><strong>快速失败</strong>。如果发生了运行时错误，发生错误的进程会立刻停止执行，并借由消息机制传递错误，使其他进程能够帮助处理错误，或者干脆重启发生错误的进程。</li>
<li><strong>代码热更新</strong>。如果是其它语言，当代码发生变动需要重新部署时，比如紧急修复了一个 bug，你需要停止正在运行的服务器，编译后再重新运行新程序。但是使用 Erlang，你不需要停机，不需要停机，只需要利用消息机制通知服务器，更换模块即可，Erlang 虚拟机会自动加载新模块，达到“热更新”。</li>
<li><strong>分布式</strong>。Erlang 为分布式集群的实现提供了相当易用的函数，在集群的不同节点间通信与进程间通信的实现大同小异。如果熟悉了 Erlang 的消息机制，那么使用 Erlang 实现简单的分布式集群的学习成本近乎于零。</li>
</ul>
<p>Erlang 的以上特性让它特别适合于实现高可靠、高性能的服务器。然而 Erlang 并不是一门新手友好的语言，且不说它属于函数式范型，光是它那受 Prolog 影响颇深的语法，也让人望而生畏。所以本文虽是快速入门，但也需要读者有一定的功力，<strong>熟悉至少一门静态类型语言和动态类型语言</strong>。否则，强行修炼，必将走火入魔。本文中涉及到的源代码可以在 <a href="https://gist.github.com/loggerhead/48facfaab6db640c2b3f">Gist</a> 获取。</p>


<div class="toc">
<ul>
<li><a href="#_1">环境</a><ul>
<li><a href="#_2">安装</a></li>
<li><a href="#_3">运行</a></li>
<li><a href="#_4">运行环境差异</a></li>
</ul>
</li>
<li><a href="#_5">语法</a><ul>
<li><a href="#_6">注释</a></li>
<li><a href="#_7">变量</a></li>
<li><a href="#_8">模式匹配</a></li>
<li><a href="#_9">数据类型</a></li>
<li><a href="#_10">布尔运算</a></li>
<li><a href="#_11">数学运算</a></li>
<li><a href="#_12">元组匹配</a></li>
<li><a href="#_13">列表操作</a></li>
<li><a href="#_14">比特语法</a></li>
<li><a href="#_15">模块</a></li>
<li><a href="#_16">函数</a><ul>
<li><a href="#_17">匿名函数</a></li>
<li><a href="#_18">函数定义</a></li>
</ul>
</li>
<li><a href="#if-case">if 与 case 表达式</a></li>
<li><a href="#record">Record</a></li>
<li><a href="#_19">宏定义</a></li>
<li><a href="#_20">异常</a></li>
<li><a href="#_21">进程与消息</a></li>
</ul>
</li>
<li><a href="#_22">参考</a></li>
</ul>
</div>
<h1 id="_1">环境</h1>
<h2 id="_2">安装</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># Linux</span>
sudo apt-get install erlang
<span class="c1"># OSX</span>
brew install erlang
</pre></div>
</td></tr></table>

<p>官方的 Erlang Shell 是不带语法高亮的，如果需要高亮，可以安装 <a href="https://github.com/karlll/kjell">kjell</a>。</p>
<h2 id="_3">运行</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span>erl
<span class="c1">#查看 erl 手册</span>
erl -man erl
<span class="c1">#查看 `lists` 模块手册</span>
erl -man lists
</pre></div>
</td></tr></table>

<p>在 <code>erl</code> 中按下 <code>CTRL+G</code> 中断正在运行的程序，如果没有运行的程序，那么再输入 <code>q</code> 退出 <code>erl</code>（连按两次 <code>CTRL+C</code> 也能退出），或者输入 <code>h</code> 查看可使用的命令。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">1&gt;</span>
<span class="go">User switch command</span>
<span class="go">--&gt; h</span>
<span class="go">c [nn]            - connect to job</span>
<span class="go">i [nn]            - interrupt job</span>
<span class="go">k [nn]            - kill job</span>
<span class="go">j                 - list all jobs</span>
<span class="go">s [shell]         - start local shell</span>
<span class="go">r [node [shell]]  - start remote shell</span>
<span class="go">q        - quit erlang</span>
<span class="go">? | h             - this message</span>
</pre></div>
</td></tr></table>

<p>为了与命令行的 shell 相区分，下文使用 <code>erl</code> 代指 Erlang Shell。</p>
<h2 id="_4">运行环境差异</h2>
<ul>
<li><code>erl</code> 只能计算表达式，所以不能定义函数，不能使用 <code>-</code> 开头的编译命令</li>
<li><a href="http://linux.die.net/man/3/c">常用函数的缩写</a>只能在 <code>erl</code> 中使用</li>
<li><a href="http://www.erlang.org/doc/man/escript.html">escript</a>、<code>erl</code> 和模块三者不尽相同</li>
</ul>
<h1 id="_5">语法</h1>
<h2 id="_6">注释</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% `%` 在 Erlang 中表单行注释</span>
<span class="c">% Erlang 没有多行注释</span>
<span class="c">%% 用几个 `%` 来注释只是风格问题</span>
</pre></div>
</td></tr></table>

<h2 id="_7">变量</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% 变量必须以大写字母或下划线开头</span>
<span class="c">% 英文句号表示语句的结束</span>
<span class="nv">Num</span> <span class="o">=</span> <span class="mi">42</span><span class="p">.</span>

<span class="c">% 变量只有绑定和未绑定两种状态</span>
<span class="c">% 变量在第一次匹配时被绑定</span>
<span class="c">% 已被绑定的变量不能再改变它的值</span>
<span class="c">% Num = 1.</span>
</pre></div>
</td></tr></table>

<h2 id="_8">模式匹配</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% `=` 并不是赋值，而是模式匹配</span>
<span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span>
<span class="c">% 模式匹配的意思是：先计算右边的值，再将结果与左边进行匹配</span>
<span class="nv">Answer</span> <span class="o">=</span> <span class="mi">42</span><span class="p">.</span>
<span class="mi">42</span> <span class="o">=</span> <span class="nv">Answer</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<h2 id="_9">数据类型</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% 浮点数</span>
<span class="nv">Pi</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14</span><span class="p">.</span>

<span class="c">% Atom 以小写字母开始（所以变量必须以大写字母开始），可以由字母、数字、`_` 或 `@` 组成</span>
<span class="nv">Bar</span> <span class="o">=</span> <span class="n">for_example</span><span class="p">@</span><span class="n">bar</span><span class="p">.</span>
<span class="c">% 被单引号括起来的也是 atom</span>
<span class="nv">Foo</span> <span class="o">=</span> <span class="n">&#39;?! 2333...&#39;</span><span class="p">.</span>
<span class="c">% `true` 和 `false` 只是约定用来做布尔运算的 atom</span>
<span class="n">true</span> <span class="ow">and</span> <span class="n">false</span><span class="p">.</span>

<span class="c">% 被花括号括起来的是元组</span>
<span class="nv">Point</span> <span class="o">=</span> <span class="p">{</span><span class="n">point</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span>

<span class="c">% 被中括号括起来的是列表</span>
<span class="nv">Nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span>
<span class="c">% 被双引号括起来的是字符串</span>
<span class="nv">Word</span> <span class="o">=</span> <span class="s">&quot;Hi&quot;</span><span class="p">.</span>
<span class="c">% 字符串实际上是由整数组成的列表</span>
<span class="p">[</span><span class="mi">72</span><span class="p">,</span> <span class="mi">105</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Hi&quot;</span><span class="p">.</span>

<span class="c">% 字符以 `$` 开头，表示该字符对应的数字</span>
<span class="sc">$\n</span><span class="p">.</span>  <span class="c">% 10</span>
<span class="sc">$a</span><span class="p">.</span>   <span class="c">% 97</span>
</pre></div>
</td></tr></table>

<p>详见<a href="http://erlang.org/doc/reference_manual/typespec.html">官方文档</a>。</p>
<h2 id="_10">布尔运算</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% `and` 类似于函数调用 `and(ExprA, ExprB)`</span>
<span class="n">false</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ok</span> <span class="o">==</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;hi &quot;</span><span class="p">)).</span>     <span class="c">% hi false</span>
<span class="c">% `andalso` 和其他语言一样，具有短路性质。当 `ExprA == false` 时，不计算 `ExprB`</span>
<span class="n">false</span> <span class="ow">andalso</span> <span class="p">(</span><span class="n">ok</span> <span class="o">==</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;hi &quot;</span><span class="p">)).</span> <span class="c">% false</span>
<span class="c">% 不具有短路性质的逻辑或</span>
<span class="n">true</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ok</span> <span class="o">==</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;hi &quot;</span><span class="p">)).</span>       <span class="c">% hi true</span>
<span class="c">% 具有短路性质的逻辑或</span>
<span class="n">true</span> <span class="ow">orelse</span> <span class="p">(</span><span class="n">ok</span> <span class="o">==</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;hi &quot;</span><span class="p">)).</span>   <span class="c">% true</span>
<span class="c">% 逻辑非</span>
<span class="ow">not</span> <span class="n">true</span><span class="p">.</span>

<span class="c">% 值相等吗？</span>
<span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span>
<span class="c">% 值相等且类型一致吗？</span>
<span class="mi">1</span> <span class="o">=:=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span>
<span class="c">% 值不相等吗？</span>
<span class="mi">1</span> <span class="o">/=</span> <span class="mi">1</span><span class="p">.</span>
<span class="c">% 值不相等或类型不相等吗？</span>
<span class="mi">1</span> <span class="o">=/=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span>

<span class="c">% 大于</span>
<span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">.</span>
<span class="c">% 不是 &#39;&lt;=&#39; 哦！</span>
<span class="mi">1</span> <span class="o">=&lt;</span> <span class="mi">2</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<h2 id="_11">数学运算</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span><span class="p">.</span>   <span class="c">% 2.5</span>
<span class="mi">5</span> <span class="ow">div</span> <span class="mi">2</span><span class="p">.</span> <span class="c">% 2</span>
<span class="mi">5</span> <span class="ow">rem</span> <span class="mi">2</span><span class="p">.</span> <span class="c">% 1</span>
<span class="c">% 语法 `Base#Value` 用于表示其他进制的数（2&lt;=Base&lt;=36）</span>
<span class="mi">2#101010</span> <span class="o">=</span> <span class="mi">8#052</span> <span class="o">=</span> <span class="mi">16#2A</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<h2 id="_12">元组匹配</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% `_` 是匿名变量，用来匹配任何值</span>
<span class="p">{_,</span> <span class="p">_,</span> <span class="nv">Y</span><span class="p">}</span> <span class="o">=</span> <span class="nv">Point</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<h2 id="_13">列表操作</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nv">List</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span>
<span class="c">% `[Head|Tail] = List` 匹配列表的头和尾</span>
<span class="p">[</span><span class="nv">Head</span><span class="p">|</span><span class="nv">Tail</span><span class="p">]</span> <span class="o">=</span> <span class="nv">List</span><span class="p">.</span>  <span class="c">% Head = 1, Tail = [2, 3].</span>
<span class="nb">hd</span><span class="p">(</span><span class="nv">List</span><span class="p">)</span> <span class="o">=:=</span> <span class="nv">Head</span><span class="p">.</span>
<span class="nb">tl</span><span class="p">(</span><span class="nv">List</span><span class="p">)</span> <span class="o">=:=</span> <span class="nv">Tail</span><span class="p">.</span>

<span class="c">% `[Head|Tail]` 还可以用来组成新列表</span>
<span class="nv">ListPlus</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">|</span><span class="nv">List</span><span class="p">].</span> <span class="c">% [0, 1, 2, 3]</span>
<span class="c">% 合并成新列表</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span>    <span class="c">% [1, 2, 3, 4]</span>

<span class="c">% 剔除列表元素</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">--</span> <span class="p">[</span><span class="mi">2</span><span class="p">].</span>    <span class="c">% [4, 2]</span>

<span class="c">% 表达式 `[F(X) || X &lt;- L]` 产生了一个新列表</span>
<span class="c">% 新列表的每个元素由列表 L 中的每个元素进行运算 F(X) 得到</span>
<span class="nv">Double</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nv">X</span> <span class="p">||</span> <span class="nv">X</span> <span class="o">&lt;-</span> <span class="nv">List</span><span class="p">].</span>                   <span class="c">% [2, 4, 6]</span>
<span class="c">% 满足 `X rem 2 == 0` 的元素才计算 `2*X`</span>
<span class="nv">DoubleEven</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nv">X</span> <span class="p">||</span> <span class="nv">X</span> <span class="o">&lt;-</span> <span class="nv">List</span><span class="p">,</span> <span class="nv">X</span> <span class="ow">rem</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">].</span> <span class="c">% [4]</span>

<span class="c">% 计算与原点的距离</span>
<span class="nv">Points</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}].</span>
<span class="p">[</span><span class="nn">math</span><span class="p">:</span><span class="nf">sqrt</span><span class="p">(</span><span class="nv">X</span><span class="o">*</span><span class="nv">X</span> <span class="o">+</span> <span class="nv">Y</span><span class="o">*</span><span class="nv">Y</span><span class="p">)</span> <span class="p">||</span> <span class="p">{</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nv">Points</span><span class="p">].</span> <span class="c">% [1.4142135623730951,13.0,5.0]</span>
<span class="c">% 计算笛卡尔积</span>
<span class="p">[{</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="p">||</span> <span class="nv">X</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="nv">Y</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]].</span>       <span class="c">% [{1,3},{1,4},{2,3},{2,4}]</span>
<span class="c">% 筛选</span>
<span class="p">[</span><span class="nv">Y</span> <span class="p">||</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="nv">Points</span><span class="p">].</span>                    <span class="c">% [4]</span>
</pre></div>
</td></tr></table>

<h2 id="_14">比特语法</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% 被 `&lt;&lt;` 和 `&gt;&gt;` 括起来的值会被转换为二进制数据</span>
<span class="nv">Color</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="mi">16#010203</span><span class="p">:</span><span class="mi">24</span><span class="o">&gt;&gt;</span><span class="p">.</span>
<span class="o">&lt;&lt;</span><span class="nv">Red</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="nv">Green</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="nv">Blue</span><span class="p">:</span><span class="mi">8</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nv">Color</span><span class="p">.</span>
<span class="o">&lt;&lt;</span><span class="s">&quot;hello, world&quot;</span><span class="o">&gt;&gt;</span><span class="p">.</span>

<span class="c">% binaries 的遍历操作和列表类似</span>
<span class="c">% 只不过是使用 `&lt;=` 而不是 `&lt;-`（所以小于等于采用 `=&lt;`）</span>
<span class="p">[</span><span class="nv">X</span> <span class="p">||</span> <span class="o">&lt;&lt;</span><span class="nv">X</span><span class="o">&gt;&gt;</span> <span class="o">&lt;=</span> <span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;&gt;</span><span class="p">].</span>            <span class="c">% [1,2,3,4]</span>
<span class="o">&lt;&lt;</span> <span class="o">&lt;&lt;</span><span class="nv">X</span><span class="o">&gt;&gt;</span> <span class="p">||</span> <span class="o">&lt;&lt;</span><span class="nv">X</span><span class="o">&gt;&gt;</span> <span class="o">&lt;=</span> <span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;&gt;</span> <span class="o">&gt;&gt;</span><span class="p">.</span>    <span class="c">% &lt;&lt;1,2,3,4&gt;&gt;</span>
</pre></div>
</td></tr></table>

<p>详见 <a href="http://www.erlang.org/documentation/doc-5.6/doc/programming_examples/bit_syntax.html">bit syntax</a>。</p>
<h2 id="_15">模块</h2>
<p><a href="http://erlang.org/doc/reference_manual/modules.html">模块</a>必须存储在后缀为 <code>.erl</code> 的文件中，且 <strong>只能由模块属性和函数定义组成</strong>，下面以 <code>test.erl</code> 为例说明如何使用模块。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% 模块属性以 `-` 开头</span>
<span class="c">% module 属性是必须的，且参数必须与除去后缀的文件名一致</span>
<span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">test</span><span class="p">).</span>

<span class="c">% import 属性用来导入其他模块的函数，然后才能在模块中使用</span>
<span class="c">% -import(Module, [Function1/Arity, ..., FunctionN/Arity]).</span>
<span class="c">% 其中 Arity 是函数的参数数目</span>
</pre></div>
</td></tr></table>

<p>模块必须编译才能使用 <sup id="fnref:code_loading"><a class="footnote-ref" href="#fn:code_loading" rel="footnote">1</a></sup>，编译成功会生成 <code>test.beam</code> 文件。编译有多种方式，如：</p>
<ul>
<li>使用 <a href="http://erlang.org/doc/man/erlc.html">erlc</a> 进行编译：<code>erlc test.erl</code></li>
<li>在 <code>erl</code> 中执行 <code>c(test).</code></li>
</ul>
<p><a href="http://erlang.org/doc/man/code.html">模块在第一次引用时被自动加载</a>，所以在调用模块中的函数时，不需要运行 <code>import</code> 之类的语句（python 就需要）。<sup id="fnref:module_load"><a class="footnote-ref" href="#fn:module_load" rel="footnote">2</a></sup></p>
<h2 id="_16">函数</h2>
<h3 id="_17">匿名函数</h3>
<p>表达式 <code>fun(X) -&gt; Expression end.</code> 返回 <em>函数</em> 作为表达式的值。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% Erlang 对缩进不敏感，所以也可以写成多行</span>
<span class="nv">Foo</span> <span class="o">=</span> <span class="k">fun</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="n">do_nothing_but_return_a_atom</span>
<span class="k">end</span><span class="p">.</span>
<span class="c">% 任何函数都有返回值，最后一个表达式的值会被当作返回值</span>
<span class="nv">Foo</span><span class="p">().</span>
<span class="c">% 匿名函数可以在 erl 中执行</span>
<span class="mi">4</span> <span class="o">=:=</span> <span class="k">fun</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">X</span><span class="o">*</span><span class="nv">X</span> <span class="k">end</span> <span class="p">(</span><span class="mi">2</span><span class="p">).</span>
</pre></div>
</td></tr></table>

<h3 id="_18">函数定义</h3>
<p><a href="http://erlang.org/doc/reference_manual/functions.html">函数</a>不能在 <code>erl</code> 中定义，所以我们将函数定义写在 <code>mymethod.erl</code> 模块中。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% mymethod.erl</span>
<span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">mymethod</span><span class="p">).</span>

<span class="c">% 要想在外部调用模块中的函数，首先得将函数导出</span>
<span class="c">% -export([Function1/Arity, ..., FunctionN/Arity]).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">hi</span><span class="o">/</span><span class="mi">0</span><span class="p">]).</span>

<span class="c">% 调试的时候可以使用下面的语句导出所有函数</span>
<span class="c">% -compile(export_all).</span>

<span class="c">% 不需要 `end`</span>
<span class="nf">hi</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="s">&quot;hello, world&quot;</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<p>函数名是一个 atom，函数定义的形式如下：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% 函数头部</span>
<span class="nf">function</span><span class="p">(</span><span class="nv">Arg1</span><span class="p">,</span> <span class="nv">Arg2</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">Arg3</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="c">% 函数体</span>
    <span class="nv">Expression1</span><span class="p">,</span>
    <span class="nv">Expression2</span><span class="p">,</span>
    <span class="p">...</span>
    <span class="c">% 表达式的结果作为返回值</span>
    <span class="nv">ExpressionN</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<p>其他语言中的 <code>if ... else ...</code> 可以通过函数分句和模式匹配来实现：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all_the_same</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</td></tr></table>

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% 按函数分句的先后顺序进行模式匹配</span>
<span class="c">% 找到第一个参数匹配的分句时，执行该分句下的表达式</span>
<span class="c">% 分号表分句的结束，句号表整个函数的结束</span>
<span class="nf">all_the_same</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">true</span><span class="p">;</span>
<span class="c">% `_` 是匿名变量</span>
<span class="nf">all_the_same</span><span class="p">(_,</span> <span class="p">_,</span> <span class="p">_)</span> <span class="o">-&gt;</span> <span class="n">false</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<p>有时候需要匹配一定范围内的值，这时候模式匹配就略显不足了。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">is_adult</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">false</span><span class="p">;</span>
<span class="p">...</span>
<span class="nf">is_adult</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">false</span><span class="p">;</span>
<span class="nf">is_adult</span><span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">true</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<p>所以 Erlang 有 guard（断言）。Guard 以 <code>when</code> 关键字开头，可出现在 <strong>函数头部</strong> 或 <strong>表达式</strong> 中。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">is_adult</span><span class="p">(</span><span class="nv">Age</span><span class="p">)</span> <span class="k">when</span> <span class="nv">Age</span> <span class="o">&lt;</span> <span class="mi">18</span> <span class="o">-&gt;</span> <span class="n">false</span><span class="p">;</span>
<span class="nf">is_adult</span><span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">true</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<p>Guard 可以由一系列 guard 表达式组成。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% 逗号在 guard 中的作用类似于 `and`</span>
<span class="nf">is_triangle</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">,</span> <span class="nv">C</span><span class="p">)</span> <span class="k">when</span> <span class="nv">A</span><span class="o">+</span><span class="nv">B</span> <span class="o">&gt;</span> <span class="nv">C</span><span class="p">,</span> <span class="nv">B</span><span class="o">+</span><span class="nv">C</span> <span class="o">&gt;</span> <span class="nv">A</span><span class="p">,</span> <span class="nv">A</span><span class="o">+</span><span class="nv">C</span> <span class="o">&gt;</span> <span class="nv">B</span> <span class="o">-&gt;</span> <span class="n">true</span><span class="p">;</span>
<span class="nf">is_triangle</span><span class="p">(_,</span> <span class="p">_,</span> <span class="p">_)</span> <span class="o">-&gt;</span> <span class="n">false</span><span class="p">.</span>

<span class="c">% 分号在 guard 中的作用类似于 `or`</span>
<span class="nf">is_num</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="k">when</span> <span class="nb">is_integer</span><span class="p">(</span><span class="nv">X</span><span class="p">);</span> <span class="nb">is_float</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">true</span><span class="p">;</span>
<span class="nf">is_num</span><span class="p">(_)</span> <span class="o">-&gt;</span> <span class="n">false</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<p>下面给出几个例子帮助你熟悉函数定义：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">bro</span><span class="p">(</span><span class="nv">Girlfriend</span><span class="p">)</span> <span class="k">when</span> <span class="nv">Girlfriend</span> <span class="o">==</span> <span class="n">girl</span> <span class="o">-&gt;</span> 
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;fall in love with </span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">Girlfriend</span><span class="p">]);</span>
<span class="c">% 若参数未被使用，编译时会发出警告：`Warning: variable &#39;Girl&#39; is unused`</span>
<span class="c">% 如果参数名以下划线开头，则不会警告</span>
<span class="nf">bro</span><span class="p">(_</span><span class="nv">Girl</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;cheat!</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">).</span>

<span class="c">% 参数数目不同但同名的函数没有任何关系</span>
<span class="nf">bro</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;I&#39;m a single dog</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">).</span>

<span class="c">% 根据参数的模式匹配执行不同的分句</span>
<span class="nf">yo</span><span class="p">(</span><span class="n">brother</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;Hi, man!</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nf">yo</span><span class="p">(</span><span class="n">friend</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;How are you?</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nf">yo</span><span class="p">(</span><span class="nv">People</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;Are you </span><span class="se">\&quot;</span><span class="si">~p</span><span class="se">\&quot;</span><span class="s">?</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">People</span><span class="p">]).</span>

<span class="c">% 计算列表的和</span>
<span class="nf">sum</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sum</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span>                    <span class="c">% 句号</span>
<span class="nf">sum</span><span class="p">([],</span> <span class="nv">Result</span><span class="p">)</span>    <span class="o">-&gt;</span> <span class="nv">Result</span><span class="p">;</span>           <span class="c">% 分号</span>
<span class="nf">sum</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sum</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">H</span><span class="o">+</span><span class="nv">Result</span><span class="p">).</span> <span class="c">% 又是句号，为什么？</span>
</pre></div>
</td></tr></table>

<p>在 <code>erl</code> 中编译并运行。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% 编译当前目录下的 `mymethod.erl` 模块</span>
<span class="nf">c</span><span class="p">(</span><span class="n">mymethod</span><span class="p">).</span>
<span class="c">% 可以使用 `cd` 切换目录</span>
<span class="c">% cd(&quot;/path/to/where/you/saved/the-module/&quot;).</span>

<span class="c">% 函数调用的形式是：`Module:Function(Arguments).`</span>
<span class="c">% erl 会寻找 `Module.beam` 文件中 `Function` 的定义</span>
<span class="nn">mymethod</span><span class="p">:</span><span class="nf">hi</span><span class="p">().</span>
<span class="c">% 内建函数（BIFs: built-in functions）会被自动导入，不需要指出模块名</span>
<span class="nf">date</span><span class="p">().</span>
<span class="c">% `seq` 并没有被自动导入，但你可以直接使用</span>
<span class="nn">lists</span><span class="p">:</span><span class="nf">seq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">).</span> <span class="c">% [1,2,3,4]</span>
</pre></div>
</td></tr></table>

<p>查看更多内建函数点<a href="http://linux.die.net/man/3/Erlang">这里</a>。</p>
<h2 id="if-case">if 与 case 表达式</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% `if` 类似于 guard，并且语法和 guard 一致</span>
<span class="nf">hi_if</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> 
    <span class="c">% `if` 也有返回值</span>
    <span class="nv">Result</span> <span class="o">=</span> <span class="k">if</span> 
        <span class="c">% 必须匹配所有的逻辑，否则会 crash</span>
        <span class="nv">X</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">positive</span><span class="p">;</span>
        <span class="nv">X</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">zero</span><span class="p">;</span>
        <span class="c">% 匹配剩下的所有可能</span>
        <span class="n">true</span> <span class="o">-&gt;</span> <span class="n">negative</span>
    <span class="k">end</span><span class="p">,</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;if expression result is &#39;</span><span class="si">~p</span><span class="s">&#39;</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">Result</span><span class="p">]).</span>

<span class="c">% `case` 类似于函数头部，其余部分和 `if` 几乎一样</span>
<span class="nf">hi_case</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Result</span> <span class="o">=</span> <span class="k">case</span> <span class="nv">X</span> <span class="k">of</span>
        <span class="nv">X</span> <span class="k">when</span> <span class="nv">X</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">positive</span><span class="p">;</span>
        <span class="nv">X</span> <span class="k">when</span> <span class="nv">X</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">zero</span><span class="p">;</span>
        <span class="c">% 匹配剩下的所有可能</span>
        <span class="p">_</span> <span class="o">-&gt;</span> <span class="n">negative</span>
    <span class="k">end</span><span class="p">,</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;case expression result is &#39;</span><span class="si">~p</span><span class="s">&#39;</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">Result</span><span class="p">]).</span>
</pre></div>
</td></tr></table>

<h2 id="record">Record</h2>
<p><a href="http://erlang.org/doc/reference_manual/records.html">Record</a> 是一种类似于 C 语言中结构体的数据结构，它会在编译期间被转换成元组。record 定义不能出现在 <code>erl</code> 中，但是可以定义在 <code>.erl</code> 或 <code>.hrl</code> 中，这里我们定义在 <code>bar.hrl</code> 中。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% bar.hrl</span>
<span class="c">% record 将元组中的元素绑定到特定的名称</span>
<span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">point</span><span class="p">,</span> <span class="p">{</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">}).</span> 
<span class="c">% 本质是元组 `{point, X = 0, Y = undefined}`</span>
</pre></div>
</td></tr></table>

<p>然后在 <code>erl</code> 中使用 record。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% 使用函数 `rr`（read records）导入 record 的定义</span>
<span class="nf">rr</span><span class="p">(</span><span class="s">&quot;bar.hrl&quot;</span><span class="p">).</span>  

<span class="c">% 创建 record</span>
<span class="nv">P0</span> <span class="o">=</span> <span class="nl">#point</span><span class="p">{}.</span>               <span class="c">% #point{x = 0,y = undefined}</span>
<span class="nv">P1</span> <span class="o">=</span> <span class="nl">#point</span><span class="p">{</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}.</span>          <span class="c">% #point{x = 0,y = 0}</span>
<span class="c">% 在 `P1` 的基础上创建 record</span>
<span class="nv">P2</span> <span class="o">=</span> <span class="nv">P1</span><span class="nl">#point</span><span class="p">{</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">}.</span>        <span class="c">% #point{x = 1,y = 0}</span>
<span class="c">% 读取 record 的成员</span>
<span class="nv">P2</span><span class="nl">#point.x</span> <span class="o">+</span> <span class="nv">P2</span><span class="nl">#point.y</span><span class="p">.</span>     <span class="c">% 1</span>
</pre></div>
</td></tr></table>

<p>当然，你也可以在模块中使用。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% bar.erl</span>
<span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">bar</span><span class="p">).</span>
<span class="p">-</span><span class="ni">include</span><span class="p">(</span><span class="s">&quot;bar.hrl&quot;</span><span class="p">).</span>
<span class="p">-</span><span class="ni">compile</span><span class="p">(</span><span class="n">export_all</span><span class="p">).</span>

<span class="nf">distance</span><span class="p">(</span><span class="nv">P</span><span class="p">)</span> <span class="k">when</span> <span class="nb">is_number</span><span class="p">(</span><span class="nv">P</span><span class="nl">#point.x</span><span class="p">),</span> <span class="nb">is_number</span><span class="p">(</span><span class="nv">P</span><span class="nl">#point.y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">math</span><span class="p">:</span><span class="nf">sqrt</span><span class="p">(</span><span class="nv">P</span><span class="nl">#point.x</span><span class="o">*</span><span class="nv">P</span><span class="nl">#point.x</span> <span class="o">+</span> <span class="nv">P</span><span class="nl">#point.y</span><span class="o">*</span><span class="nv">P</span><span class="nl">#point.y</span><span class="p">).</span>

<span class="c">% record 在 function clause 中的匹配很违背直觉</span>
<span class="c">% 仅匹配 `#point.y == 1`，而不管 `#point.x` 是不是 `0`</span>
<span class="nf">test</span><span class="p">(</span><span class="nl">#point</span><span class="p">{</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">fwrite</span><span class="p">(</span><span class="s">&quot;x=? y=1</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="c">% 仅匹配 `#point.x == 1`，而不管 `#point.y` 是什么值</span>
<span class="nf">test</span><span class="p">(</span><span class="nl">#point</span><span class="p">{</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">fwrite</span><span class="p">(</span><span class="s">&quot;x=1 y=?</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">).</span>

<span class="nf">test</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nv">P1</span> <span class="o">=</span> <span class="nl">#point</span><span class="p">{</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
    <span class="nv">P2</span> <span class="o">=</span> <span class="p">{</span><span class="n">point</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
    <span class="k">case</span> <span class="n">distance</span><span class="p">(</span><span class="nv">P1</span><span class="p">)</span> <span class="o">=:=</span> <span class="n">distance</span><span class="p">(</span><span class="nv">P2</span><span class="p">)</span> <span class="k">of</span>
        <span class="n">true</span> <span class="o">-&gt;</span> <span class="n">ok</span><span class="p">;</span>
        <span class="n">false</span> <span class="o">-&gt;</span> <span class="n">error</span><span class="p">(</span><span class="s">&quot;Oh My God! This is impossible!&quot;</span><span class="p">)</span>
    <span class="k">end</span><span class="p">,</span>
    <span class="n">test</span><span class="p">(</span><span class="nl">#point</span><span class="p">{</span><span class="n">x</span> <span class="o">=</span> <span class="n">whatever</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">}),</span> <span class="c">% x=? y=1</span>
    <span class="n">test</span><span class="p">(</span><span class="nl">#point</span><span class="p">{</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">}),</span>        <span class="c">% x=? y=1</span>
    <span class="n">test</span><span class="p">(</span><span class="nl">#point</span><span class="p">{</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">whatever</span><span class="p">}).</span> <span class="c">% x=1 y=?</span>
</pre></div>
</td></tr></table>

<p>详见<a href="http://erlang.org/doc/reference_manual/records.html">官方文档</a>。</p>
<h2 id="_19">宏定义</h2>
<p>宏定义的语法如下：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">Const</span><span class="p">,</span> <span class="nv">Replacement</span><span class="p">).</span>
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">Func</span><span class="p">(</span><span class="nv">Var1</span><span class="p">,...,</span><span class="nv">VarN</span><span class="p">),</span> <span class="nv">Replacement</span><span class="p">).</span>
</pre></div>
</td></tr></table>

<p>我们新建一个 <code>mymath.erl</code> 文件实验宏定义。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% mymath.erl</span>
<span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">mymath</span><span class="p">).</span>
<span class="p">-</span><span class="ni">compile</span><span class="p">(</span><span class="n">export_all</span><span class="p">).</span>
<span class="c">% 自定义的宏</span>
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">ONE</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
<span class="p">-</span><span class="ni">define</span><span class="p">(</span><span class="no">ADD</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="nv">X</span><span class="o">+</span><span class="nv">Y</span><span class="p">).</span>

<span class="nf">test</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;predefined macros: </span><span class="si">~n</span><span class="s">&quot;</span><span class="p">),</span> 
    <span class="c">% 预定义的宏</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;</span><span class="si">~p</span><span class="s"> </span><span class="si">~p</span><span class="s"> </span><span class="si">~p</span><span class="s"> </span><span class="si">~p</span><span class="s"> </span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="o">?</span><span class="nv">MODULE_STRING</span><span class="p">,</span> <span class="o">?</span><span class="nv">FILE</span><span class="p">,</span> <span class="o">?</span><span class="nv">LINE</span><span class="p">,</span> <span class="o">?</span><span class="nv">MACHINE</span><span class="p">]),</span>
    <span class="c">% `?MACRO` 调用宏</span>
    <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;one=</span><span class="si">~p</span><span class="s"> add(1,2)=</span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">?</span><span class="nv">ONE</span><span class="p">,</span> <span class="o">?</span><span class="nv">ADD</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]).</span>
</pre></div>
</td></tr></table>

<p>然后在 <code>erl</code> 中编译运行。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">c</span><span class="p">(</span><span class="n">mymath</span><span class="p">).</span>
<span class="nn">mymath</span><span class="p">:</span><span class="nf">test</span><span class="p">().</span>
<span class="c">% predefined macros:</span>
<span class="c">% mymath &quot;mymath&quot; &quot;mymath.erl&quot; 8 &#39;BEAM&#39;</span>
<span class="c">% one=1 add(1,2)=3</span>
</pre></div>
</td></tr></table>

<p>详见<a href="http://erlang.org/doc/reference_manual/macros.html">官方文档</a>。</p>
<h2 id="_20">异常</h2>
<p>捕获异常的语法如下：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="nv">Expression</span> <span class="k">of</span>
    <span class="c">% guards 是可选的</span>
    <span class="nv">SuccessfulPattern1</span> <span class="p">[</span><span class="nv">Guards</span><span class="p">]</span> <span class="o">-&gt;</span>
        <span class="nv">Expression1</span><span class="p">;</span>
    <span class="nv">SuccessfulPattern2</span> <span class="p">[</span><span class="nv">Guards</span><span class="p">]</span> <span class="o">-&gt;</span>
        <span class="nv">Expression2</span>
<span class="k">catch</span>
    <span class="nv">TypeOfError</span><span class="p">:</span><span class="nv">ExceptionPattern1</span> <span class="o">-&gt;</span>
        <span class="nv">Expression3</span><span class="p">;</span>
    <span class="nv">TypeOfError</span><span class="p">:</span><span class="nv">ExceptionPattern2</span> <span class="o">-&gt;</span>
        <span class="nv">Expression4</span>
<span class="c">% after 语句在 `try...catch` 语句之后执行</span>
<span class="k">after</span> 
    <span class="nv">Expr3</span>
<span class="k">end</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<p>我们新建 <code>catcher.erl</code> 文件，对 <code>try...catch</code> 语句进行实验。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% catcher.erl</span>
<span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">catcher</span><span class="p">).</span>
<span class="p">-</span><span class="ni">compile</span><span class="p">(</span><span class="n">export_all</span><span class="p">).</span>

<span class="c">% `throw`, `exit`, `error` 三者都能产生异常</span>
<span class="nf">do_something</span><span class="p">(</span><span class="n">throw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">throw</span><span class="p">(</span><span class="n">lol</span><span class="p">);</span>      <span class="c">% ** exception throw: lol</span>
<span class="nf">do_something</span><span class="p">(</span><span class="nb">exit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">exit</span><span class="p">(</span><span class="n">lol</span><span class="p">);</span>        <span class="c">% ** exception exit: lol</span>
<span class="nf">do_something</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">error</span><span class="p">(</span><span class="n">lol</span><span class="p">);</span>      <span class="c">% ** exception error: lol</span>
<span class="nf">do_something</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">X</span><span class="p">.</span>

<span class="nf">normal_catcher</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">try</span> <span class="n">do_something</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="k">of</span>
        <span class="nv">Result</span> <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;do_something(</span><span class="si">~p</span><span class="s">) =&gt; </span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Result</span><span class="p">])</span>
    <span class="k">catch</span>
        <span class="nn">throw</span><span class="p">:</span><span class="nv">E</span> <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;catch throw: </span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">E</span><span class="p">]);</span>
        <span class="nb">exit</span><span class="p">:</span><span class="nv">E</span>  <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;catch exit: </span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">E</span><span class="p">]);</span>
        <span class="nn">error</span><span class="p">:</span><span class="nv">E</span> <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;catch error: </span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">E</span><span class="p">])</span>
    <span class="k">end</span><span class="p">.</span>

<span class="nf">all_catcher</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">try</span> <span class="n">do_something</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="k">of</span>
        <span class="nv">Result</span> <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;do_something(</span><span class="si">~p</span><span class="s">) =&gt; </span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Result</span><span class="p">])</span>
    <span class="k">catch</span>
        <span class="c">% 省略错误类型</span>
        <span class="c">% 默认为 throw 类型</span>
        <span class="nv">E</span> <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;catch you: </span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">E</span><span class="p">])</span>
    <span class="k">after</span>
        <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;after `try...catch`</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">end</span><span class="p">.</span>

<span class="nf">simple_catcher</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="c">% 将异常转换为一个描述异常的元组</span>
    <span class="c">% 如果没有异常，则返回表达式的值</span>
    <span class="k">catch</span> <span class="n">do_something</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</td></tr></table>

<h2 id="_21">进程与消息</h2>
<p>Erlang 的每个进程都有一个消息队列保存收到的消息，而 receive 语句是用来从消息队列中提取消息的。receive 会遍历消息队列，直到找到能够匹配的消息，将其从消息队列中移除，并执行相应的 receive 处理逻辑。<sup id="fnref:conc_prog"><a class="footnote-ref" href="#fn:conc_prog" rel="footnote">3</a></sup></p>
<p>receive 的语法如下：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">receive</span>
    <span class="nv">Pattern1</span> <span class="p">[</span><span class="nv">Guards1</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nv">Expressions1</span><span class="p">;</span>
    <span class="nv">Pattern2</span> <span class="p">[</span><span class="nv">Guards2</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nv">Expressions2</span>
<span class="c">% after 语句是可选的，意为：</span>
<span class="c">% 如果 `Timeout` 毫秒后没收到消息，执行 `Expressions3`</span>
<span class="k">after</span> <span class="nv">Timeout</span> <span class="o">-&gt;</span>
    <span class="nv">Expressions3</span>
<span class="k">end</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<p>发送消息的语法很简单：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nv">Pid</span> <span class="o">!</span> <span class="nv">Message</span><span class="p">.</span>
</pre></div>
</td></tr></table>

<p>我们在 <code>erl</code> 中直观的感受一下接发消息的过程。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% `self()` 获取当前进程的 pid</span>
<span class="c">% `process_info(Pid)` 用来查看进程运行时信息</span>
<span class="c">% 返回结果中的 `messages` 字段就是消息队列的内容</span>
<span class="nb">process_info</span><span class="p">(</span><span class="n">self</span><span class="p">()).</span>

<span class="c">% 向 Erlang shell 进程发送一个消息 `hi`</span>
<span class="nf">self</span><span class="p">()</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="s">&quot;a_more_complex_case&quot;</span><span class="p">}.</span>
<span class="nf">self</span><span class="p">()</span> <span class="o">!</span> <span class="n">hi</span><span class="p">.</span>
<span class="nf">self</span><span class="p">()</span> <span class="o">!</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">am</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">list</span><span class="p">].</span>
<span class="c">% 现在消息队列中有两个消息了</span>
<span class="nb">process_info</span><span class="p">(</span><span class="n">self</span><span class="p">()).</span>

<span class="k">receive</span>
    <span class="n">hi</span> <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;get hi</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="k">end</span><span class="p">.</span>
<span class="k">receive</span>
    <span class="nv">Msg</span> <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;get: </span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">Msg</span><span class="p">])</span>
<span class="k">end</span><span class="p">.</span>
<span class="c">% 被 receive 取完后，消息队列就空了</span>
<span class="nb">process_info</span><span class="p">(</span><span class="n">self</span><span class="p">()).</span>
</pre></div>
</td></tr></table>

<p>下面新建一个 <code>m.erl</code> 文件实验一些更复杂的例子。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% m.erl</span>
<span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">m</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">start_echo</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_hurry</span><span class="o">/</span><span class="mi">0</span><span class="p">]).</span>

<span class="nf">echo</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="k">receive</span>
        <span class="p">{</span><span class="nv">From</span><span class="p">,</span> <span class="nv">Msg</span><span class="p">}</span> <span class="o">-&gt;</span>
            <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;</span><span class="si">~p</span><span class="s"> =&gt; </span><span class="si">~p</span><span class="s">: </span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">From</span><span class="p">,</span> <span class="n">self</span><span class="p">(),</span> <span class="nv">Msg</span><span class="p">]),</span>
            <span class="nv">From</span> <span class="o">!</span> <span class="nv">Msg</span><span class="p">,</span>
            <span class="c">% 循环接收消息</span>
            <span class="n">echo</span><span class="p">()</span>
    <span class="c">% 如果10秒内没收到消息，就执行 after 语句</span>
    <span class="k">after</span> <span class="mi">10000</span> <span class="o">-&gt;</span>
        <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;quit echo process</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">end</span><span class="p">.</span>

<span class="c">% `after 0` 的逻辑类似于：</span>
<span class="c">% if is_not_empty(message_queue)</span>
<span class="c">%     receive()</span>
<span class="c">% else</span>
<span class="c">%     after()</span>
<span class="nf">do_hurry</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="k">receive</span>
        <span class="nv">Msg</span> <span class="o">-&gt;</span>
            <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;message: &#39;</span><span class="si">~p</span><span class="s">&#39;</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">Msg</span><span class="p">]),</span>
            <span class="n">do_hurry</span><span class="p">()</span>
    <span class="k">after</span> <span class="mi">0</span> <span class="o">-&gt;</span>
        <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;no more message, quit</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">end</span><span class="p">.</span>

<span class="c">% 等待10秒后从消息队列中取出所有消息</span>
<span class="nf">hurry</span><span class="p">(</span><span class="nv">Wait</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">timer</span><span class="p">:</span><span class="nf">sleep</span><span class="p">(</span><span class="nv">Wait</span><span class="p">),</span>
    <span class="n">do_hurry</span><span class="p">().</span>

<span class="nf">start_echo</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="c">% 调用 `spawn` 启动新进程，并返回一个pid（进程标识符）</span>
    <span class="c">% 在 `erl` 中调用为 `spawn(Function)`，在模块中为 `spawn(fun Function/0)`</span>
    <span class="nb">spawn</span><span class="p">(</span><span class="k">fun</span> <span class="n">echo</span><span class="o">/</span><span class="mi">0</span><span class="p">).</span>

<span class="nf">start_hurry</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nb">spawn</span><span class="p">(</span><span class="k">fun</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">hurry</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="k">end</span><span class="p">).</span>
</pre></div>
</td></tr></table>

<p>然后在 <code>erl</code> 中运行。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% 启动新进程，将新进程 pid 与 `E` 绑定</span>
<span class="nv">E</span> <span class="o">=</span> <span class="nn">m</span><span class="p">:</span><span class="nf">start_echo</span><span class="p">().</span>
<span class="c">% Erlang shell 进程发送消息 &quot;hi&quot; 给 `E` 进程</span>
<span class="nv">E</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="s">&quot;hi&quot;</span><span class="p">}.</span>
<span class="c">% 接收 `echo` 传回的消息</span>
<span class="k">receive</span> 
    <span class="nv">Msg</span> <span class="o">-&gt;</span> <span class="nn">io</span><span class="p">:</span><span class="nf">format</span><span class="p">(</span><span class="s">&quot;received from echo:</span><span class="si">~p~n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">Msg</span><span class="p">])</span> 
<span class="k">end</span><span class="p">.</span>
<span class="c">% 如果10秒没有再发消息给 `E` 进程，它会执行 after</span>

<span class="nv">H</span> <span class="o">=</span> <span class="nn">m</span><span class="p">:</span><span class="nf">start_hurry</span><span class="p">().</span>
<span class="nv">H</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="s">&quot;hello&quot;</span><span class="p">}.</span>
<span class="nv">H</span> <span class="o">!</span> <span class="n">yo</span><span class="p">.</span>
<span class="nv">H</span> <span class="o">!</span> <span class="p">[</span><span class="n">hi</span><span class="p">,</span> <span class="n">bro</span><span class="p">].</span>
</pre></div>
</td></tr></table>

<hr />
<h1 id="_22">参考</h1>
<ul>
<li><a href="http://learnxinyminutes.com/docs/Erlang/">Learn X in Y minutes: Erlang</a></li>
<li><a href="http://learnyousomeErlang.com/">Learn You Some Erlang</a></li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:code_loading">
<p><a href="http://erlang.org/doc/reference_manual/code_loading.html">Compilation and Code Loading</a>&#160;<a class="footnote-backref" href="#fnref:code_loading" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:module_load">
<p>实际上还得分 <strong>嵌入式</strong> 和 <strong>交互式</strong> 两种运行模式来讨论。前者在启动时一次加载完所有的代码，后者在启动时加载一部分基本的模块，其他模块则在第一次引用时动态加载。&#160;<a class="footnote-backref" href="#fnref:module_load" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:conc_prog">
<p>详见官方文档 <a href="http://www.erlang.org/doc/getting_started/conc_prog.html">Concurrent Programming</a>&#160;<a class="footnote-backref" href="#fnref:conc_prog" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      </div>
    </article>
  </section>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
    this.page.identifier = "Erlang 快速入门";
};

(function() {
    var d = document, s = d.createElement('script');
    s.async = true;
    s.src = "//loggerhead.disqus.com/embed.js";
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>      </div>
    </div>
  </div>
</div>

 <footer class="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-xs-8">
        <p>
          &copy;2016&nbsp; <a href="..">loggerhead</a>
        </p>
      </div>
      <div class="col-xs-4">
        <p class="pull-right">
          <a href="#" class="back-to-top">
            <span class="glyphicon glyphicon-arrow-up" aria-hidden="true"></span>
            回到顶部
          </a>
        </p>
      </div>
    </div>

    <div class="row hidden-when-phone">
      <div class="col-xs-8">
        <p>
          <a href="http://www.miitbeian.gov.cn/" target="_blank">粤ICP备16007488号</a>
          &middot; Powered by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a>
        </p>

        <p>
          本站文章均为原创，并遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh_TW" target="_blank">CC BY-SA 4.0 协议</a>
        </p>
      </div><!--/.col-xs-8 -->

      <div class="col-xs-4">
        <p class="pull-right">
          <a href="https://www.upyun.com/zh/league.html" target="_blank">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAtCAMAAAAZUYxJAAAAtFBMVEUAAABPrtxPrtxPrtxPrtxPrtxlZ2ZlZ2ZPrtxlZ2ZRqdRlZ2ZPrtxPrtxPrtxPrtxPrtxlZ2ZPrtxlZ2ZPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxlZ2ZPrtxPrtxPrtxlZ2ZlZ2ZPrtxlZ2ZlZ2ZPrtxPrtxlZ2ZlZ2ZlZ2ZlZ2ZlZ2ZPrtxPrtxlZ2ZPrtxlZ2ZlZ2ZlZ2ZPrtxPrtxlZ2ZPrtxlZ2bPPWi/AAAAOnRSTlMAgNCQ8aAQcD8fA/FPMevhsDD5wLp1cCHZypmHOwyrooFTGhLh0sSwinlfXfju67yMRyfcooZ4RS0XProUtAAAAZlJREFUSMft02tT4jAUxvHTNtAaobjd3iyUq1zE1V1dr0++//fypMGZCrbw1jG/N2nD8KcTTsmyLOvH6sUC4Tio7fxWyufll1KKqKu0P7fLpy7veUCHlwAAfxMYELsAHKIOtCiMe2TICQxPNqeNq7OjaWNGlX+Ixo4TAxg2p6e+/8jL32PpVZomLnBJWhZdzomNQiBrTJ/x3Y1ej6Q9XQIi0tJwQZUAGC7KlrS8VermhHS/+khuR8U17cRg+bYxTUvePTUtL+5p0iejdIJ5vwCKxqc+3z315IR0wsftLMgwB51Uf+9aqc1B2uf1gYbAapc2x1p+mc4nfDGnOikQE015jje+v6lNyPPaTMgMQJGmXpUuIyBO0tQ9SFdDIumTAf4Tvd0p43CupYsP1eQaB2mBF9oTmKF8WF+dGybNF3fLaZfYYpgLAGbCZOIKg6ehEEK/Gq98R2OIraS6Xqh//zNz1ntmQEgtMgGEbg2HkZet6Z6ndQbAmNr0c+xbZdSa9rATZtRK3l87dcmIqD2duJXYmZNlWZb17b0DTmto7227YPgAAAAASUVORK5CYII=" />
          </a>
        </p>
      </div>
    </div>
  </div>
</footer>
    <script src="../theme/js/bag.2.0.2.min.js"></script>

<script id="myscripts">
bag = new window.Bag();

bag.require([
    "//cdn.bootcss.com/jquery/2.2.1/jquery.min.js",
    "//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"
]);

function load_css(url, done) {
    var link  = document.createElement('link');
    link.rel  = 'stylesheet';
    link.href = url;
    link.onload = done;
    document.head.appendChild(link);
}

function load_js(url, done) {
    var script = document.createElement('script');
    script.src = url;
    script.onload = done;
    document.body.appendChild(script);
}

function gestureStart() {
    for (i = 0; i < metas.length; i++) {
        if (metas[i].name == "viewport") {
            metas[i].content = "width=device-width, minimum-scale=0.25, maximum-scale=1.6";
        }
    }
}

(function screen_suit() {
    var metas = document.getElementsByTagName('meta');
    var ua = navigator.userAgent;
    if (ua.match(/iPhone/i)) {
        for (var i = 0; i < metas.length; i++) {
            if (metas[i].name == "viewport") {
                metas[i].content = "width=device-width, minimum-scale=1.0, maximum-scale=1.0";
            }
        }
        document.addEventListener("gesturestart", gestureStart, false);
    }
})();

// See https://gist.github.com/vartan/ab195e5a502a47e0c3e5
(function fix_hover_behavior() {
    if('ontouchstart' in document.documentElement) {
        for(var sheetI = document.styleSheets.length - 1; sheetI >= 0; sheetI--) {
            var sheet = document.styleSheets[sheetI];
            if(sheet.cssRules) {
                for(var ruleI = sheet.cssRules.length - 1; ruleI >= 0; ruleI--) {
                    var rule = sheet.cssRules[ruleI];
                    if(rule.selectorText) {
                        rule.selectorText = rule.selectorText.replace(":hover", ":active");
                    }
                }
            }
        }
    }
})();

(function add_class_to_chinese_em(class_name) {
    var ems = document.getElementsByTagName("em");

    for (var i = 0; i < ems.length; i++) {
        var text = ems[i].textContent;
        // if has chinese char
        if(/.*[\u4e00-\u9fa5]+.*$/.test(text)) {
            ems[i].className += " " + class_name;
        }
    }
})('chinese');

// IE10 viewport hack for Surface/desktop Windows 8 bug
(function fix_ie10_viewport_bug() {
    if (navigator.userAgent.match(/IEMobile\/10\.0/)) {
        bag.require([
            "//maxcdn.bootstrapcdn.com/css/ie10-viewport-bug-workaround.css",
            "//maxcdn.bootstrapcdn.com/js/ie10-viewport-bug-workaround.js"
        ]);
    }
})();

(function load_katex_when_need(class_name) {
    var maths = document.getElementsByClassName(class_name);
    if (maths.length == 0) {
        return;
    }

    bag.require([
        "//cdn.bootcss.com/KaTeX/0.6.0/katex.min.js"
    ]).then(function() {
        for (var i = 0; i < maths.length; i++) {
            var math = maths[i];

            var displayMode = null;
            if (math.tagName == "SPAN") {
                displayMode = false;
            } else if (math.tagName == "DIV") {
                displayMode = true;
            }

            if (displayMode === null) {
                console.log("Cannot render " + math);
            } else {
                try {
                    katex.render(math.textContent, maths[i], { displayMode: displayMode });
                } catch (err) {
                    console.log(err);
                }
            }
        }
    });

    load_css("//cdn.bootcss.com/KaTeX/0.6.0/katex.min.css");
})("math");
</script>

<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script>
  bag.require([
    "//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js",
    "//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"
  ]);
  </script>
<![endif]-->
 
</body>
</html>