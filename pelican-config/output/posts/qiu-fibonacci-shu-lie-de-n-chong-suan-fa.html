<!Doctype html>
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<meta name="renderer" content="webkit">
<meta name="HandheldFriendly" content="True">
<meta name="google-site-verification" content="xRiYQAQ0h0n3RXqrq0GgrdFm3BMFqDvDwwiRylv0YhQ">

<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="theme-color" content="#ffffff">
<meta name="author" content="loggerhead" />    <meta name="keywords" content="算法,Python" />

  <meta name="description" content="高中学过一个神奇的数列——Fibonacci 数列，它的特点是：除了最初的两个 Fibonacci 数以外，其余的所有 Fibonacci 数都等于前两个 Fibonacci 数之和。表达成数学公式就是： F_{n}=\begin{cases} 0 &amp; n=0\\ 1 &amp; n=1\\ F_{n-1}+F_{n-2} &amp; n\geq 2 \end{cases} 下面是 Fibonacci 数列的头几项（0 是第零项）。 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ..." />

  <title>  求 Fibonacci 数列的 N 种算法
</title>

<link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">

  <link rel="stylesheet" href="../theme/css/style.1cd8932.css">
 
  <link rel="icon" type="image/x-icon" href="/favicon.ico">

  <link href="../atom.xml" rel="alternate" type="application/atom+xml">
</head>
<body>

<nav class="navbar navbar-default navbar-static-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="..">loggerhead's blog</a>
    </div>
    <div class="collapse navbar-collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav">
        <li><a href="../index.html">首页</a></li>
        <li><a href="../archives.html">归档</a></li>
        <li><a href="../404.html">关于</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="https://github.com/loggerhead" target="_blank">GitHub</a></li>
        <li><a href="https://www.hackerrank.com/loggerhead" target="_blank">HackerRank</a></li>
        <li><a href="https://douban.com/people/loggerhead" target="_blank">豆瓣</a></li>
      </ul>
    </div><!--/.navbar-header -->
  </div><!--/.container -->
</nav><!--/.navbar -->

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="markdown-body article-list">
  <section id="content">
    <article>
      <header class="page-header">
        <h1>
          <a class="article-title" href="../posts/qiu-fibonacci-shu-lie-de-n-chong-suan-fa.html" rel="bookmark" title="Permalink to 求 Fibonacci 数列的 N 种算法">
            求 Fibonacci 数列的 N 种算法
          </a>
        </h1>
<footer class="post-info">
  <div class="row">
    <div class="col-xs-8">
      <!-- <span class="label label-default">Tags</span> -->
        <a class="tag btn btn-xs" href="../tag/suan-fa.html">
          算法
        </a>
        <a class="tag btn btn-xs" href="../tag/python.html">
          Python
        </a>
    </div>

    <div class="col-xs-4 time">
      <time class="pull-right" datetime="2015-10-28T21:58:40+08:00">
        2015-10-28
      </time>
    </div>
  </div>
</footer>        <hr>
      </header>
      <div class="entry-content">
        <p>高中学过一个神奇的数列——Fibonacci 数列，它的特点是：除了最初的两个 Fibonacci 数以外，其余的所有 Fibonacci 数都等于前两个 Fibonacci 数之和。表达成数学公式就是：</p>
<div class="math">
F_{n}=\begin{cases}
      0               &amp; n=0\\
      1               &amp; n=1\\
      F_{n-1}+F_{n-2} &amp; n\geq 2
      \end{cases}
</div>
<p>下面是 Fibonacci 数列的头几项（0 是第零项）。</p>
<div class="math">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233...</div>
<p>同时，Fibonacci 数列也出现在很多计算机相关的书上面，那么我们怎么编程求第 n 个 Fibonacci 数呢？<sup id="fnref:source code"><a class="footnote-ref" href="#fn:source code" rel="footnote">1</a></sup></p>


<h1 id="o2n-on"><span class="math">O(2^n), O(n)</span></h1>
<p>首先，很自然的想法是直接将通项公式“翻译”成代码。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fib1</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">fib1</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib1</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>几乎没什么难度，但是如果你这样就满足了，那只能说实在是 “too young, too simple”。这种算法存在一个很严重的问题——当输入稍微大一点的时候，比如：42，需要运行很久，速度非常慢。</p>
<p>原因在于，<code>fib1(n-1) + fib1(n-2)</code> 中的递归导致算法的时间复杂度是指数型的，也就是 <span class="math">O(2^n)</span><sup id="fnref:fib1 time complexity"><a class="footnote-ref" href="#fn:fib1 time complexity" rel="footnote">2</a></sup>。假设计算 <span class="math">F_n</span> 需要 <span class="math">T(n)</span> 的运算时间，那么 <span class="math">T(n)</span> 等于计算 <span class="math">F_{n-1}</span> 和 <span class="math">F_{n-2}</span> 的时间加上一个常量 <span class="math">C</span>（<code>if</code>、<code>+</code> 和 <code>return</code> 的时间）。</p>
<div class="math">T(n)=T(n-1)+T(n-2)+C &lt; 2\times T(n-1) = O(2^n) \qquad n\rightarrow\infty</div>
<p>再来看 <code>fib1(n)</code> 的空间复杂度，容易发现递归的最大深度是 n，所以递归形成的隐式栈占用了 <span class="math">O(n)</span> 的空间，即空间复杂度为 <span class="math">O(n)</span>。如果把递归过程看成一颗树，那么空间复杂度正比于树的高度，时间复杂度正比于树的节点数。</p>
<p><img alt="complexity of fib1" src="https://dn-loggerhead.qbox.me/images/fib1.svg" /></p>
<h1 id="on-on"><span class="math">O(n), O(n)</span></h1>
<p><code>fib1</code> 进行了很多重复运算，就 <code>fib1(4)</code> 来说，<code>fib1(2)</code> 被计算了 2 次。</p>
<p><img alt="fib1_4" src="https://dn-loggerhead.qbox.me/images/fib1_4.svg" /></p>
<p>发现了这一点后，我们将 <code>fib1</code> 进行改造，记录下每一个算出来的 <span class="math">F_n</span>，避免重复计算，减少运行时间。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fib2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fib2</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib2</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>如图，<code>fib2(4)</code> 在第一次计算 <code>fib2(2)</code> 时保存了结果，第二次计算 <code>fib2(2)</code> 时就不用再递归计算了，而是直接返回 <code>fib2(2)</code> 的值。</p>
<p><img alt="fib2_4" src="https://dn-loggerhead.qbox.me/images/fib2_4.svg" /></p>
<p>因为递归的最大深度没变，所以 <code>fib2</code> 的空间复杂度还是 <span class="math">O(n)</span>。但是因为每个子问题只需要计算一次，所以时间复杂度变成了 <span class="math">O(n)</span>。</p>
<div class="math">T(n)=T(n-1)+T(n-2)+C=T(n-1)+C'+C=O(n) \qquad T(n-2)=C'</div>
<h1 id="on-o1"><span class="math">O(n), O(1)</span></h1>
<p>仔细观察递推公式 <span class="math">F_{n}=F_{n-1}+F_{n-2}</span>，发现每次计算 <span class="math">F_{n}</span> 都只需要 <span class="math">F_{n-1}</span> 和 <span class="math">F_{n-2}</span> 两个值。利用这一点，我们可以用两个变量 <code>f2</code> 和 <code>f1</code> 分别记录计算 <span class="math">F_{n}</span> 所需要的 <span class="math">F_{n-1}</span> 和 <span class="math">F_{n-2}</span>，而不是 <span class="math">F_0, F_1, ..., F_n</span> 的值，将空间复杂度降为 <span class="math">O(1)</span>。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fib3</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">f2</span><span class="p">,</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span> <span class="o">+</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span>
    <span class="k">return</span> <span class="n">f1</span>
</pre></div>
</td></tr></table>

<p><code>fib3(4)</code> 的计算过程如下图所示：</p>
<p><img alt="fib3_4" src="https://dn-loggerhead.qbox.me/images/fib3_4.svg" /></p>
<h1 id="olog-n-olog-n"><span class="math">O(\log n), O(\log n)</span></h1>
<p>在介绍 <span class="math">O(\log n)</span> 的算法前，我们先考虑一下怎么计算 <span class="math">2^n</span>。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pow2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">p</span>
</pre></div>
</td></tr></table>

<p>上述算法在计算 <span class="math">2^8</span> 时，<code>pow2(8)</code> 迭代过程中的 <code>p</code> 为：</p>
<div class="math">1, 2, 4, 8, 16, 32, 64, 128, 256</div>
<p>也就是做了 8 次运算。但是如果把 <span class="math">2^8</span> 看成是 <span class="math">2^4\times 2^4</span>，而不是 <span class="math">2\times 2^7</span>，那么计算过程就变成了：</p>
<div class="math">256=16\times 16, 16=4\times 4, 4=2\times 2</div>
<p>只需要 3 次运算。把这个想法提炼一下就有了下面这个 <span class="math">O(\log n)</span> 的递归式。</p>
<div class="math">
2^{n}=\begin{cases}
      2\times 2^{n-1}                       &amp; n=1,3,\cdots\\
      2^{\frac{n}{2}}\times 2^{\frac{n}{2}} &amp; n=2,4,\cdots
      \end{cases}
</div>
<p>对于给定的 n，递归过程中每次 n 为偶数时，问题规模减半，而 n 为奇数的次数顶多比 n 为偶数的次数多一次。比如，求 <span class="math">2^{15}</span> 的递归过程中 n 的变化是：<span class="math">15, 14, 7, 6, 3, 2, 1</span>。递归深度和运行时间都正比于问题规模减半的次数，所以时间复杂度和空间复杂度都是 <span class="math">O(\log n)</span>。把整个想法用 python 实现就是：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pow2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">pow2</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">pow2</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span>
</pre></div>
</td></tr></table>

<p>重复平方技术也可以用在求 Fibonacci 数上。</p>
<h2 id="_1">矩阵方法</h2>
<p>把 <code>fib3</code> 中的变换：</p>
<div class="math">
\begin{aligned}
f2' &amp;= f2 + f1 \\
f1' &amp;= f2  
\end{aligned}
</div>
<p>用矩阵表示就是：</p>
<div class="math">
\begin{bmatrix}
f1' &amp; f2'
\end{bmatrix}
=
\begin{bmatrix}
f1 &amp; f2
\end{bmatrix}
\times
\begin{bmatrix}
0 &amp; 1\\
1 &amp; 1
\end{bmatrix}
</div>
<p>所以 Fibonacci 数列的通项公式可以用矩阵表示为：</p>
<div class="math">
\begin{bmatrix}
F_n &amp; F_{n+1}
\end{bmatrix}
=
\begin{bmatrix}
F_0 &amp; F_1
\end{bmatrix}
\times
\begin{bmatrix}
0 &amp; 1\\
1 &amp; 1
\end{bmatrix}^n
</div>
<p>注意到其中二维矩阵的乘法也可以用重复平方技术大大减少运算时间：</p>
<div class="math">
\begin{bmatrix}
0 &amp; 1\\
1 &amp; 1
\end{bmatrix}^n
=
\begin{cases}
\begin{bmatrix}
0 &amp; 1\\
1 &amp; 1
\end{bmatrix}
\times
\begin{bmatrix}
0 &amp; 1\\
1 &amp; 1
\end{bmatrix}^{n-1}         &amp; n=1,3,\cdots\\
\begin{bmatrix}
0 &amp; 1\\
1 &amp; 1
\end{bmatrix}^{\frac{n}{2}}
\times
\begin{bmatrix}
0 &amp; 1\\
1 &amp; 1
\end{bmatrix}^{\frac{n}{2}} &amp; n=2,4,\cdots
\end{cases}
</div>
<p>其实现为：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fib4</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">calc_coefs</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> 
             <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">e</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="c1"># `n &amp; 1` == `n % 2 == 1`</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># `mmul` == `Matrix Multiplication`</span>
            <span class="k">return</span> <span class="n">mmul</span><span class="p">(</span><span class="n">calc_coefs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coef</span> <span class="o">=</span> <span class="n">calc_coefs</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mmul</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mmul</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">calc_coefs</span><span class="p">(</span><span class="n">n</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<h2 id="_2">代数方法</h2>
<p>再看看 <code>fib3</code> 中的变换：</p>
<div class="math">
\begin{aligned}
f2' &amp;= f2 + f1 \\
f1' &amp;= f2 
\end{aligned}
</div>
<p>如果我们能找到一种方法把两次变换后的 <span class="math">f2'', f1''</span> 表示成 <span class="math">f2, f1</span>，那不是又能用上重复平方技术了吗？上式等价于下式 <span class="math">p=0, q=1</span> 的特殊情况。</p>
<div class="math">
\begin{aligned}
f2' &amp;= f1\times q + f2\times q +f2\times p \\
f1' &amp;= f1\times q+f2\times q
\end{aligned}
</div>
<p>将 <span class="math">f2''</span> 和 <span class="math">f1''</span> 做代换后发现，当 <span class="math">p'=p^2+q^2, q'=q^2+2qp</span> 时，下式成立：</p>
<div class="math">
\begin{aligned}
f2'' &amp;= f1'\times q + f2'\times q +f2'\times p    \\
     &amp;= f1\times p' + f2'\times q' + f2'\times p' \\
\\
f1'' &amp;= f1'\times q+f2'\times q                   \\
     &amp;= f1\times q' + f2'\times q                 
\end{aligned}
</div>
<p>这样就能用算 <span class="math">2^n</span> 的方法来实现下面这种算法了。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fib5</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fib_iter</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fib_iter</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">f1</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="n">f2</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">+</span><span class="n">p</span><span class="p">),</span> <span class="n">f1</span><span class="o">*</span><span class="n">p</span><span class="o">+</span><span class="n">f2</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fib_iter</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="o">+</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fib_iter</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h2 id="_3">性能问题</h2>
<p>虽然上述算法理论上时间复杂度是 <span class="math">O(\log n)</span>，但当 n 较大时，发现它们的运行时间增长不符合对数型的增长。原因在于，当 n 较大时，<span class="math">F_{\frac{n}{2}}</span> 是个非常大的整数，而 <strong>大整数的乘法不是 <span class="math">O(1)</span> 的</strong>，所以 <span class="math">F_{\frac{n}{2}}\times F_{\frac{n}{2}}</span> 的开销不是个常数。如果读者对这个问题感兴趣，可以自行用 C 语言实现两个大整数（<code>long long</code> 也无法表示的整数）的乘法。</p>
<h1 id="_4">参考</h1>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/斐波那契数列">Wiki: 斐波那契数列</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_thm_1.19">计算机程序的构造和解释</a></li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:source code">
<p>文中几种算法的实现可参考我的 <a href="https://gist.github.com/loggerhead/6bf260918d07e10f273b">Gist</a>&#160;<a class="footnote-backref" href="#fnref:source code" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:fib1 time complexity">
<p><span class="math">O(2^n)</span> 是时间上界，精确的时间界是个无理数的 n 次幂&#160;<a class="footnote-backref" href="#fnref:fib1 time complexity" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      </div>
    </article>
  </section>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
    this.page.identifier = "求 Fibonacci 数列的 N 种算法";
};

(function() {
    var d = document, s = d.createElement('script');
    s.async = true;
    s.src = "//loggerhead.disqus.com/embed.js";
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>      </div>
    </div>
  </div>
</div>

 <footer class="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-xs-8">
        <p>
          &copy;2016&nbsp; <a href="..">loggerhead</a>
        </p>
      </div>
      <div class="col-xs-4">
        <p class="pull-right">
          <a href="#" class="back-to-top">
            <span class="glyphicon glyphicon-arrow-up" aria-hidden="true"></span>
            回到顶部
          </a>
        </p>
      </div>
    </div>

    <div class="row hidden-when-phone">
      <div class="col-xs-8">
        <p>
          <a href="http://www.miitbeian.gov.cn/" target="_blank">粤ICP备16007488号</a>
          &middot; Powered by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a>
        </p>

        <p>
          本站文章均为原创，并遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh_TW" target="_blank">CC BY-SA 4.0 协议</a>
        </p>
      </div><!--/.col-xs-8 -->

      <div class="col-xs-4">
        <p class="pull-right">
          <a href="https://www.upyun.com/zh/league.html" target="_blank">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAtCAMAAAAZUYxJAAAAtFBMVEUAAABPrtxPrtxPrtxPrtxPrtxlZ2ZlZ2ZPrtxlZ2ZRqdRlZ2ZPrtxPrtxPrtxPrtxPrtxlZ2ZPrtxlZ2ZPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxPrtxlZ2ZPrtxPrtxPrtxlZ2ZlZ2ZPrtxlZ2ZlZ2ZPrtxPrtxlZ2ZlZ2ZlZ2ZlZ2ZlZ2ZPrtxPrtxlZ2ZPrtxlZ2ZlZ2ZlZ2ZPrtxPrtxlZ2ZPrtxlZ2bPPWi/AAAAOnRSTlMAgNCQ8aAQcD8fA/FPMevhsDD5wLp1cCHZypmHOwyrooFTGhLh0sSwinlfXfju67yMRyfcooZ4RS0XProUtAAAAZlJREFUSMft02tT4jAUxvHTNtAaobjd3iyUq1zE1V1dr0++//fypMGZCrbw1jG/N2nD8KcTTsmyLOvH6sUC4Tio7fxWyufll1KKqKu0P7fLpy7veUCHlwAAfxMYELsAHKIOtCiMe2TICQxPNqeNq7OjaWNGlX+Ixo4TAxg2p6e+/8jL32PpVZomLnBJWhZdzomNQiBrTJ/x3Y1ej6Q9XQIi0tJwQZUAGC7KlrS8VermhHS/+khuR8U17cRg+bYxTUvePTUtL+5p0iejdIJ5vwCKxqc+3z315IR0wsftLMgwB51Uf+9aqc1B2uf1gYbAapc2x1p+mc4nfDGnOikQE015jje+v6lNyPPaTMgMQJGmXpUuIyBO0tQ9SFdDIumTAf4Tvd0p43CupYsP1eQaB2mBF9oTmKF8WF+dGybNF3fLaZfYYpgLAGbCZOIKg6ehEEK/Gq98R2OIraS6Xqh//zNz1ntmQEgtMgGEbg2HkZet6Z6ndQbAmNr0c+xbZdSa9rATZtRK3l87dcmIqD2duJXYmZNlWZb17b0DTmto7227YPgAAAAASUVORK5CYII=" />
          </a>
        </p>
      </div>
    </div>
  </div>
</footer>
    <script src="../theme/js/bag.2.0.2.min.js"></script>

<script id="myscripts">
bag = new window.Bag();

bag.require([
    "//cdn.bootcss.com/jquery/2.2.1/jquery.min.js",
    "//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"
]);

function load_css(url, done) {
    var link  = document.createElement('link');
    link.rel  = 'stylesheet';
    link.href = url;
    link.onload = done;
    document.head.appendChild(link);
}

function load_js(url, done) {
    var script = document.createElement('script');
    script.src = url;
    script.onload = done;
    document.body.appendChild(script);
}

function gestureStart() {
    for (i = 0; i < metas.length; i++) {
        if (metas[i].name == "viewport") {
            metas[i].content = "width=device-width, minimum-scale=0.25, maximum-scale=1.6";
        }
    }
}

(function screen_suit() {
    var metas = document.getElementsByTagName('meta');
    var ua = navigator.userAgent;
    if (ua.match(/iPhone/i)) {
        for (var i = 0; i < metas.length; i++) {
            if (metas[i].name == "viewport") {
                metas[i].content = "width=device-width, minimum-scale=1.0, maximum-scale=1.0";
            }
        }
        document.addEventListener("gesturestart", gestureStart, false);
    }
})();

// See https://gist.github.com/vartan/ab195e5a502a47e0c3e5
(function fix_hover_behavior() {
    if('ontouchstart' in document.documentElement) {
        for(var sheetI = document.styleSheets.length - 1; sheetI >= 0; sheetI--) {
            var sheet = document.styleSheets[sheetI];
            if(sheet.cssRules) {
                for(var ruleI = sheet.cssRules.length - 1; ruleI >= 0; ruleI--) {
                    var rule = sheet.cssRules[ruleI];
                    if(rule.selectorText) {
                        rule.selectorText = rule.selectorText.replace(":hover", ":active");
                    }
                }
            }
        }
    }
})();

(function add_class_to_chinese_em(class_name) {
    var ems = document.getElementsByTagName("em");

    for (var i = 0; i < ems.length; i++) {
        var text = ems[i].textContent;
        // if has chinese char
        if(/.*[\u4e00-\u9fa5]+.*$/.test(text)) {
            ems[i].className += " " + class_name;
        }
    }
})('chinese');

// IE10 viewport hack for Surface/desktop Windows 8 bug
(function fix_ie10_viewport_bug() {
    if (navigator.userAgent.match(/IEMobile\/10\.0/)) {
        bag.require([
            "//maxcdn.bootstrapcdn.com/css/ie10-viewport-bug-workaround.css",
            "//maxcdn.bootstrapcdn.com/js/ie10-viewport-bug-workaround.js"
        ]);
    }
})();

(function load_katex_when_need(class_name) {
    var maths = document.getElementsByClassName(class_name);
    if (maths.length == 0) {
        return;
    }

    bag.require([
        "//cdn.bootcss.com/KaTeX/0.6.0/katex.min.js"
    ]).then(function() {
        for (var i = 0; i < maths.length; i++) {
            var math = maths[i];

            var displayMode = null;
            if (math.tagName == "SPAN") {
                displayMode = false;
            } else if (math.tagName == "DIV") {
                displayMode = true;
            }

            if (displayMode === null) {
                console.log("Cannot render " + math);
            } else {
                try {
                    katex.render(math.textContent, maths[i], { displayMode: displayMode });
                } catch (err) {
                    console.log(err);
                }
            }
        }
    });

    load_css("//cdn.bootcss.com/KaTeX/0.6.0/katex.min.css");
})("math");
</script>

<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script>
  bag.require([
    "//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js",
    "//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"
  ]);
  </script>
<![endif]-->
 
</body>
</html>